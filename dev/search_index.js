var documenterSearchIndex = {"docs":
[{"location":"parallel_computing/#Parallel-Computing","page":"Parallel Computing","title":"Parallel Computing","text":"FeastKit supports multiple parallel backends:\n\nThreads: parallel = :threads\nDistributed workers: parallel = :distributed\nMPI (if available): parallel = :mpi\n\nQuick check and usage:\n\nusing FeastKit\ncap = feast_parallel_capabilities()\n@info cap\nres = feast(A, (Emin, Emax), M0=20, parallel=:threads)\n\nNote: MPI requires MPI.jl and a working MPI installation.","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"Contributions are welcome! Please open an issue or pull request with a clear description and minimal reproduction where applicable.\n\nGuidelines:\n\nKeep PRs focused and concise\nAdd tests for new features\nUpdate documentation where relevant","category":"section"},{"location":"performance/#Performance-Guide","page":"Performance Tips","title":"Performance Guide","text":"Optimize FeastKit.jl for maximum performance in your eigenvalue calculations.","category":"section"},{"location":"performance/#Table-of-Contents","page":"Performance Tips","title":"Table of Contents","text":"Performance Overview\nMemory Optimization\nComputational Efficiency\nParallel Computing\nProblem-Specific Optimizations\nBenchmarking and Profiling\n\n","category":"section"},{"location":"performance/#Performance-Overview","page":"Performance Tips","title":"Performance Overview","text":"","category":"section"},{"location":"performance/#FEAST-Algorithm-Complexity","page":"Performance Tips","title":"FEAST Algorithm Complexity","text":"The FEAST algorithm has the following computational complexity:\n\nOperation Complexity Description\nContour Integration O(ne × M₀ × T_solve) ne integration points, M₀ subspace size\nReduced Eigenvalue Problem O(M₀³) Dense eigenvalue problem\nRefinement Iterations O(k × above) k ≈ 1-5 typically\n\nWhere T_solve is the cost of solving (zB - A)X = Y linear systems.\n\nperformance: Key Performance Factors\nLinear solver efficiency: Dominates total cost (80-95%)\nNumber of integration points: Linear scaling with ne\nSubspace size M₀: Memory O(N×M₀), computation O(M₀³)\nMatrix structure: Dense vs sparse vs matrix-free\n\n","category":"section"},{"location":"performance/#Memory-Optimization","page":"Performance Tips","title":"Memory Optimization","text":"","category":"section"},{"location":"performance/#Memory-Usage-Patterns","page":"Performance Tips","title":"Memory Usage Patterns","text":"using FeastKit, LinearAlgebra\n\n# Problem sizes and memory requirements\nfunction memory_analysis(N, M0, ne=8)\n    println(\"Memory Analysis for N=$N, M₀=$M0\")\n    println(\"=\"^50)\n    \n    # Workspace memory (dominant term)\n    workspace_mb = 8 * N * M0 / 1e6  # Float64 vectors\n    \n    # Integration weights/nodes  \n    integration_mb = 16 * ne / 1e6  # Complex{Float64}\n    \n    # Reduced matrices\n    reduced_mb = 8 * M0^2 / 1e6\n    \n    println(\"Workspace vectors: $(workspace_mb) MB\")\n    println(\"Integration data: $(integration_mb) MB\") \n    println(\"Reduced matrices: $(reduced_mb) MB\")\n    println(\"Total FeastKit memory: $(workspace_mb + integration_mb + reduced_mb) MB\")\n    \n    # Matrix storage (if not matrix-free)\n    matrix_dense_gb = 8 * N^2 / 1e9\n    matrix_sparse_mb = 8 * 0.001 * N^2 / 1e6  # Assuming 0.1% density\n    \n    println(\"\\nMatrix storage (not matrix-free):\")\n    println(\"Dense matrix: $(matrix_dense_gb) GB\")\n    println(\"Sparse matrix (~0.1%): $(matrix_sparse_mb) MB\")\n    \n    return (workspace_mb, matrix_dense_gb)\nend\n\n# Analyze different problem sizes\nfor N in [1000, 10000, 100000, 1000000]\n    memory_analysis(N, 20)\n    println()\nend","category":"section"},{"location":"performance/#Memory-Optimization-Strategies","page":"Performance Tips","title":"Memory Optimization Strategies","text":"tip: Memory Optimization Tips\nUse matrix-free methods for large problems\nChoose M₀ carefully: Balance accuracy vs memory  \nReduce integration points if convergence allows\nUse iterative refinement instead of high precision\nConsider domain decomposition for very large problems","category":"section"},{"location":"performance/#Strategy-1:-Matrix-Free-Implementation","page":"Performance Tips","title":"Strategy 1: Matrix-Free Implementation","text":"# Instead of storing the full matrix\nA_matrix = create_large_matrix(n)  # Requires O(n²) memory\nresult = feast(A_matrix, interval)\n\n# Use matrix-free operations  \nfunction A_mult!(y, x)\n    # Your matrix-vector product (O(n) memory)\n    apply_operator!(y, x, parameters)\nend\n\nA_op = LinearOperator{Float64}(A_mult!, (n, n), issymmetric=true)\nresult = feast(A_op, interval, solver=:cg)","category":"section"},{"location":"performance/#Strategy-2:-Adaptive-Subspace-Sizing","page":"Performance Tips","title":"Strategy 2: Adaptive Subspace Sizing","text":"function adaptive_feast(A, interval; M0_initial=10, max_M0=50)\n    M0 = M0_initial\n    \n    while M0 <= max_M0\n        result = feast(A, interval, M0=M0)\n        \n        if result.info == 0\n            # Check if we found all eigenvalues in interval\n            if result.M < M0 * 0.8  # Found significantly fewer than M0\n                println(\"Found $(result.M) eigenvalues with M0=$M0\")\n                return result\n            end\n        end\n        \n        M0 = min(M0 + 10, max_M0)\n        println(\"Increasing M0 to $M0\")\n    end\n    \n    @warn \"May not have found all eigenvalues\"\n    return result\nend\n\n","category":"section"},{"location":"performance/#Computational-Efficiency","page":"Performance Tips","title":"Computational Efficiency","text":"","category":"section"},{"location":"performance/#Integration-Method-Selection","page":"Performance Tips","title":"Integration Method Selection","text":"Different integration methods have varying computational costs:\n\nusing FeastKit, BenchmarkTools\n\nfunction benchmark_integration_methods(A, interval)\n    methods = [\n        (0, \"Gauss-Legendre\"),\n        (1, \"Trapezoidal\"), \n        (2, \"Zolotarev\")\n    ]\n    \n    println(\"Integration Method Comparison\")\n    println(\"=\"^40)\n    \n    results = []\n    \n    for (method_id, method_name) in methods\n        println(\"\\n$method_name:\")\n        \n        # Test different numbers of integration points\n        for ne in [8, 12, 16, 24]\n            contour = feast_contour_expert(interval[1], interval[2], ne, method_id, 100)\n            \n            fpm = zeros(Int, 64)\n            feastinit!(fmp)\n            fpm[2] = ne\n            fpm[16] = method_id\n            \n            time = @elapsed begin\n                result = feast(A, interval, M0=10, fpm=fpm)\n            end\n            \n            push!(results, (method_name, ne, time, result.M, result.info))\n            println(\"  ne=$ne: $(time) s, found $(result.M), status $(result.info)\")\n        end\n    end\n    \n    return results\nend\n\n# Run benchmark\nA = SymTridiagonal(2.0 * ones(1000), -1.0 * ones(999))\nresults = benchmark_integration_methods(A, (0.1, 1.0))\n\nperformance: Integration Method Guidelines\nGauss-Legendre: Highest accuracy per point, best for smooth problems\nZolotarev: Optimal for elliptical contours, excellent for clustered eigenvalues\nTrapezoidal: Simplest, good for initial experiments","category":"section"},{"location":"performance/#Linear-Solver-Optimization","page":"Performance Tips","title":"Linear Solver Optimization","text":"The linear solver dominates computational cost. Choose wisely:\n\nfunction benchmark_solvers(A_op, B_op, interval)\n    solvers = [\n        (:cg, \"Conjugate Gradient\", (rtol=1e-8, maxiter=1000)),\n        (:gmres, \"GMRES\", (rtol=1e-8, restart=30, maxiter=1000)),\n        (:bicgstab, \"BiCGSTAB\", (rtol=1e-8, l=2, maxiter=1000))\n    ]\n    \n    println(\"Linear Solver Comparison\")\n    println(\"=\"^30)\n    \n    for (solver, name, opts) in solvers\n        println(\"\\n$name:\")\n        \n        try\n            time = @elapsed begin\n                result = feast(A_op, B_op, interval, M0=10, \n                              solver=solver, solver_opts=opts)\n            end\n            \n            println(\"  Time: $(time) s\")\n            println(\"  Found: $(result.M) eigenvalues\")  \n            println(\"  Status: $(result.info == 0 ? \"Success\" : \"Failed\")\")\n            println(\"  Final residual: $(result.epsout)\")\n            \n        catch e\n            println(\"  Failed: $e\")\n        end\n    end\nend\n\ntip: Solver Selection Guidelines\nCG: Best for symmetric positive definite (SPD) systems\nGMRES: General purpose, works for any nonsingular system\nBiCGSTAB: Good for systems with complex eigenvalues near shifts\n\n","category":"section"},{"location":"performance/#Parallel-Computing","page":"Performance Tips","title":"Parallel Computing","text":"","category":"section"},{"location":"performance/#Shared-Memory-Parallelization","page":"Performance Tips","title":"Shared Memory Parallelization","text":"using FeastKit, LinearAlgebra\nBLAS.set_num_threads(8)  # Use 8 threads for BLAS operations\n\n# Enable threading in FeastKit\nresult = feast(A, interval, M0=20, parallel=:threads)","category":"section"},{"location":"performance/#Distributed-Memory-Parallelization","page":"Performance Tips","title":"Distributed Memory Parallelization","text":"using Distributed, FeastKit\n\n# Add worker processes\naddprocs(4)\n\n@everywhere using FeastKit\n\n# Distributed FeastKit\nresult = feast(A, interval, M0=20, parallel=:mpi)","category":"section"},{"location":"performance/#Hybrid-Parallelization","page":"Performance Tips","title":"Hybrid Parallelization","text":"# Use both MPI and threading\nBLAS.set_num_threads(4)  # 4 threads per MPI process\n\nresult = feast(A, interval, M0=20, parallel=:hybrid)","category":"section"},{"location":"performance/#Performance-Scaling-Analysis","page":"Performance Tips","title":"Performance Scaling Analysis","text":"function scaling_study(A, interval)\n    thread_counts = [1, 2, 4, 8, 16]\n    results = []\n    \n    println(\"Parallel Scaling Study\")\n    println(\"=\"^30)\n    \n    # Serial baseline\n    BLAS.set_num_threads(1)\n    serial_time = @elapsed begin\n        result_serial = feast(A, interval, M0=20, parallel=false)\n    end\n    \n    println(\"Serial: $(serial_time) s (baseline)\")\n    \n    # Test different thread counts\n    for nthreads in thread_counts[2:end]\n        BLAS.set_num_threads(nthreads)\n        \n        parallel_time = @elapsed begin\n            result_parallel = feast(A, interval, M0=20, parallel=:threads)\n        end\n        \n        speedup = serial_time / parallel_time\n        efficiency = speedup / nthreads\n        \n        println(\"$nthreads threads: $(parallel_time) s, speedup $(speedup), efficiency $(efficiency)\")\n        push!(results, (nthreads, parallel_time, speedup, efficiency))\n    end\n    \n    return results\nend\n\n","category":"section"},{"location":"performance/#Problem-Specific-Optimizations","page":"Performance Tips","title":"Problem-Specific Optimizations","text":"","category":"section"},{"location":"performance/#Sparse-Matrix-Optimizations","page":"Performance Tips","title":"Sparse Matrix Optimizations","text":"using SparseArrays, FeastKit\n\nfunction optimize_sparse_feast(A_sparse, interval)\n    println(\"Sparse Matrix Optimization\")\n    println(\"Matrix: $(size(A_sparse, 1))×$(size(A_sparse, 2)), nnz: $(nnz(A_sparse))\")\n    \n    # Strategy 1: Direct sparse solver (for small-medium problems)\n    if size(A_sparse, 1) < 50000\n        println(\"\\nUsing direct sparse solver:\")\n        time_direct = @elapsed begin\n            result_direct = feast(A_sparse, interval, M0=20)\n        end\n        println(\"Time: $(time_direct) s, Found: $(result_direct.M)\")\n    end\n    \n    # Strategy 2: Matrix-free with iterative solver\n    println(\"\\nUsing matrix-free iterative solver:\")\n    A_mult!(y, x) = mul!(y, A_sparse, x)\n    A_op = LinearOperator{Float64}(A_mult!, size(A_sparse), issymmetric=issymmetric(A_sparse))\n    \n    time_iterative = @elapsed begin\n        result_iterative = feast(A_op, interval, M0=20, \n                               solver=:gmres, \n                               solver_opts=(rtol=1e-6, restart=50))\n    end\n    println(\"Time: $(time_iterative) s, Found: $(result_iterative.M)\")\n    \n    # Strategy 3: Preconditioned iterative solver\n    println(\"\\nUsing preconditioned iterative solver:\")\n    P = create_preconditioner(A_sparse)  # Your preconditioner\n    \n    time_precond = @elapsed begin\n        result_precond = feast(A_op, interval, M0=20,\n                              solver=:gmres,\n                              solver_opts=(rtol=1e-6, Pl=P, restart=30))\n    end\n    println(\"Time: $(time_precond) s, Found: $(result_precond.M)\")\nend\n\nfunction create_preconditioner(A)\n    # Example: Incomplete LU preconditioner\n    return ilu(A, τ=0.01)  # Requires Preconditioners.jl\nend","category":"section"},{"location":"performance/#Eigenvalue-Distribution-Optimization","page":"Performance Tips","title":"Eigenvalue Distribution Optimization","text":"function optimize_for_distribution(A, interval, eigenvalue_density=\"uniform\")\n    if eigenvalue_density == \"clustered\"\n        # Use more integration points and Zolotarev method\n        contour = feast_contour_expert(interval[1], interval[2], 24, 2, 100)\n        \n        fpm = zeros(Int, 64)\n        feastinit!(fpm)\n        fmp[2] = 24      # More integration points\n        fpm[16] = 2      # Zolotarev integration\n        fpm[3] = 14      # Higher precision\n        \n        result = feast(A, interval, M0=30, fpm=fpm)\n        \n    elseif eigenvalue_density == \"sparse\"\n        # Use fewer integration points, lower precision\n        result = feast(A, interval, M0=10, \n                      integration_points=8, \n                      tolerance=1e-8)\n        \n    else  # uniform\n        # Default settings work well\n        result = feast(A, interval, M0=20)\n    end\n    \n    return result\nend\n\n","category":"section"},{"location":"performance/#Benchmarking-and-Profiling","page":"Performance Tips","title":"Benchmarking and Profiling","text":"","category":"section"},{"location":"performance/#Comprehensive-Benchmarking-Suite","page":"Performance Tips","title":"Comprehensive Benchmarking Suite","text":"using FeastKit, BenchmarkTools, Profile\n\nfunction feast_benchmark_suite()\n    println(\"FeastKit.jl Comprehensive Benchmark Suite\")\n    println(\"=\"^50)\n    \n    # Test problems of increasing size\n    problems = [\n        (1000, \"Small\"),\n        (10000, \"Medium\"), \n        (50000, \"Large\"),\n        (100000, \"Very Large\")\n    ]\n    \n    results = Dict()\n    \n    for (n, size_name) in problems\n        println(\"\\n$size_name Problem (N=$n)\")\n        println(\"-\"^30)\n        \n        # Create test matrix\n        A = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\n        interval = (0.01, 0.1)\n        \n        # Benchmark different approaches\n        approaches = [\n            (\"Dense\", () -> feast(Matrix(A), interval, M0=10)),\n            (\"Sparse\", () -> feast(sparse(A), interval, M0=10)),\n            (\"Matrix-Free\", () -> begin\n                A_mult!(y, x) = mul!(y, A, x)\n                A_op = LinearOperator{Float64}(A_mult!, (n, n), issymmetric=true)\n                feast(A_op, interval, M0=10, solver=:cg)\n            end)\n        ]\n        \n        results[size_name] = []\n        \n        for (approach_name, approach_func) in approaches\n            try\n                # Warm up\n                if n <= 10000  # Skip warmup for very large problems\n                    approach_func()\n                end\n                \n                # Benchmark\n                benchmark = @benchmark $approach_func() seconds=30 samples=5\n                median_time = median(benchmark).time / 1e9  # Convert to seconds\n                \n                println(\"$approach_name: $(median_time) s\")\n                push!(results[size_name], (approach_name, median_time))\n                \n            catch e\n                println(\"$approach_name: Failed ($e)\")\n                push!(results[size_name], (approach_name, Inf))\n            end\n        end\n    end\n    \n    # Summary table\n    println(\"\\n\" * \"=\"^60)\n    println(\"BENCHMARK SUMMARY\")  \n    println(\"=\"^60)\n    @printf(\"%-12s %-12s %-12s %-12s\\\\n\", \"Size\", \"Dense (s)\", \"Sparse (s)\", \"Matrix-Free (s)\")\n    println(\"-\"^60)\n    \n    for (size_name, size_results) in results\n        times = Dict(name => time for (name, time) in size_results)\n        @printf(\"%-12s %-12.3f %-12.3f %-12.3f\\\\n\", \n                size_name, \n                get(times, \"Dense\", Inf),\n                get(times, \"Sparse\", Inf), \n                get(times, \"Matrix-Free\", Inf))\n    end\n    \n    return results\nend\n\n# Run comprehensive benchmark\nresults = feast_benchmark_suite()","category":"section"},{"location":"performance/#Profiling-FeastKit-Performance","page":"Performance Tips","title":"Profiling FeastKit Performance","text":"using Profile, ProfileView\n\nfunction profile_feast(A, interval)\n    println(\"Profiling FeastKit Performance\")\n    \n    # Profile a typical FeastKit run\n    @profile result = feast(A, interval, M0=20)\n    \n    # Show profile results\n    Profile.print()\n    \n    # Interactive profile view (if ProfileView.jl is available)\n    try\n        ProfileView.view()\n    catch\n        println(\"Install ProfileView.jl for interactive profiling\")\n    end\n    \n    return result\nend\n\n# Example usage\nA = SymTridiagonal(2.0 * ones(5000), -1.0 * ones(4999))\nprofile_feast(A, (0.1, 1.0))","category":"section"},{"location":"performance/#Memory-Profiling","page":"Performance Tips","title":"Memory Profiling","text":"function memory_profile_feast(A, interval)\n    println(\"Memory Profiling FeastKit\")\n    \n    # Track memory allocation\n    GC.gc()  # Clean up before profiling\n    initial_memory = Base.gc_bytes()\n    \n    result = feast(A, interval, M0=20)\n    \n    GC.gc()\n    final_memory = Base.gc_bytes()\n    \n    allocated_mb = (final_memory - initial_memory) / 1e6\n    println(\"Total memory allocated: $(allocated_mb) MB\")\n    \n    # Detailed allocation tracking\n    @time result = feast(A, interval, M0=20)\n    \n    return result\nend\n\n","category":"section"},{"location":"performance/#Performance-Checklist","page":"Performance Tips","title":"Performance Checklist","text":"success: Pre-Optimization Checklist\n[ ] Problem size: Use matrix-free for N > 50,000\n[ ] Matrix type: Sparse for <1% density, matrix-free for larger\n[ ] Eigenvalue distribution: Clustered → more integration points\n[ ] Search interval: Tight intervals → faster convergence\n[ ] Subspace size M₀: 1.5-2× expected number of eigenvalues\n\ntip: Solver Optimization Checklist\n[ ] CG for SPD: Symmetric positive definite problems\n[ ] GMRES for general: Non-symmetric or indefinite problems\n[ ] Preconditioner: For poorly conditioned systems\n[ ] Tolerance: Balance accuracy vs speed (1e-6 to 1e-12)\n[ ] Max iterations: Increase for difficult problems\n\nperformance: Parallelization Checklist\n[ ] BLAS threads: Set to number of physical cores\n[ ] FeastKit parallel: Use :threads for shared memory\n[ ] MPI: For distributed memory systems  \n[ ] Load balancing: Ensure even work distribution\n[ ] Communication: Minimize for distributed systems\n\n\n\n<div align=\"center\">   <p><strong>Optimize your FeastKit.jl calculations for maximum performance</strong></p>   ← Examples | API Reference → </div>","category":"section"},{"location":"zero_to_feast/#Zero-to-FeastKit:-A-Practical-Guide","page":"Zero to FeastKit","title":"Zero to FeastKit: A Practical Guide","text":"New to FeastKit or eigenvalue problems? This guide takes you from zero knowledge to running robust FeastKit computations — step by step.","category":"section"},{"location":"zero_to_feast/#What-You’ll-Learn","page":"Zero to FeastKit","title":"What You’ll Learn","text":"What FeastKit does and when to use it\nHow to install and verify FeastKit\nHow to solve standard and generalized eigenvalue problems\nHow to scale from dense to sparse to matrix-free\nHow to target complex eigenvalues and custom contours\nHow to tune performance and select parallel backends\n\n","category":"section"},{"location":"zero_to_feast/#1)-Mental-Model:-What-is-FeastKit?","page":"Zero to FeastKit","title":"1) Mental Model: What is FeastKit?","text":"FeastKit finds eigenvalues in a region you choose — not all eigenvalues at once.\nYou provide a search interval [Emin, Emax] (real) or a circle (center, radius) (complex).\nFeastKit integrates resolvent operators along a contour to filter eigenvalues inside the region.\nIt scales well for large problems and works with dense, sparse, and matrix-free operators.\n\nWhen to use FeastKit:\n\nYou know where the eigenvalues of interest live (e.g., “smallest 10”, “near 0”, or “inside this circle”).\nYour matrix is too large for full eigen-decomposition.\nYou need a robust, parallel-friendly approach.\n\n","category":"section"},{"location":"zero_to_feast/#2)-Installation-and-Verification","page":"Zero to FeastKit","title":"2) Installation and Verification","text":"# In Julia REPL (press ] to enter Pkg mode)\npkg> add FeastKit\n\n# Back to Julia mode\njulia> using FeastKit, LinearAlgebra\n\n# Quick verification\na = [2.0 -1.0; -1.0 2.0]\nres = feast(a, (0.1, 5.0), M0=4)\n@info \"FeastKit OK\" M=res.M info=res.info lambda=res.lambda[1:res.M]\n\nExpected: info == 0 and two eigenvalues found near 1 and 3.\n\n","category":"section"},{"location":"zero_to_feast/#3)-First-Solve:-Standard-Symmetric-Problem","page":"Zero to FeastKit","title":"3) First Solve: Standard Symmetric Problem","text":"Simple tridiagonal Laplacian (dense or sparse):\n\nusing FeastKit, LinearAlgebra, SparseArrays\n\n# 1D Laplacian on n points\nn = 200\nA = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))\n\n# Target low end of spectrum\nEmin, Emax = 0.0, 0.2\nres = feast(A, (Emin, Emax), M0=16)\n\n@assert res.info == 0\n@info \"Found\" M=res.M vals=res.lambda[1:res.M]\n\nTips:\n\nM0 is the max desired eigenvalues; choose slightly larger than expected.\nIf res.M == 0, broaden the interval or validate bounds (see Section 8).\n\n","category":"section"},{"location":"zero_to_feast/#4)-Generalized-Problem-A-x-λ-B-x","page":"Zero to FeastKit","title":"4) Generalized Problem A x = λ B x","text":"Common in structural dynamics and PDEs:\n\nusing FeastKit, LinearAlgebra, SparseArrays\n\nn = 1000\nK = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))  # stiffness\nM = spdiagm(0 => ones(n))                                        # mass\n\nres = feast(K, M, (0.0, 0.5), M0=20)\n@info \"Generalized\" info=res.info M=res.M\n\n","category":"section"},{"location":"zero_to_feast/#5)-Matrix-Free:-No-Matrix-Stored","page":"Zero to FeastKit","title":"5) Matrix-Free: No Matrix Stored","text":"When storing A is infeasible, supply y = A*x as a function:\n\nusing FeastKit\n\nfunction lap1d_matvec!(y, x)\n    n = length(x)\n    y[1] = 2x[1] - x[2]\n    @inbounds for i in 2:n-1\n        y[i] = -x[i-1] + 2x[i] - x[i+1]\n    end\n    y[n] = -x[n-1] + 2x[n]\nend\n\nn = 200_000\nAop = LinearOperator{Float64}(lap1d_matvec!, (n, n), issymmetric=true)\nres = feast(Aop, (0.0, 0.2), M0=12)  # internally uses iterative solves\n@info \"Matrix-free\" info=res.info M=res.M\n\nNotes:\n\nUse efficient BLAS/threading inside matvec! for speed.\nYou can choose iterative solvers and tolerances via kwargs if exposed in your version.\n\n","category":"section"},{"location":"zero_to_feast/#6)-Complex-Eigenvalues:-Non-Hermitian-Problems","page":"Zero to FeastKit","title":"6) Complex Eigenvalues: Non-Hermitian Problems","text":"Search in a circular region of the complex plane:\n\nusing FeastKit\n\nA = [2.0  5.0; -3.0  1.0]  # non-symmetric\nI2 = Matrix{Float64}(I, 2, 2)\ncenter, radius = 1.0 + 1.0im, 3.0\nres = feast_general(A, I2, center, radius, M0=8)\n@info \"Complex region\" info=res.info M=res.M λ=res.lambda[1:res.M]\n\n","category":"section"},{"location":"zero_to_feast/#7)-From-Defaults-to-Expert-Parameters","page":"Zero to FeastKit","title":"7) From Defaults to Expert Parameters","text":"Parameters live in fpm::Vector{Int} (length ≥ 64):\n\nfpm = zeros(Int, 64)\nfeastinit!(fpm)\nfpm[1] = 1     # print level (0=silent, 1=summary)\nfpm[2] = 16    # integration points (8–32 typical)\nfpm[3] = 12    # tolerance exponent (target ~ 1e-12)\nfpm[4] = 30    # max refinement loops\n\nres = feast(A, (Emin, Emax), M0=20, fpm=fpm)\n\nExpert controls (see docs for details):\n\nIntegration type: Gauss/Trapezoidal/Zolotarev via fpm[16]\nEllipse aspect ratio via fpm[18]\nCustom contours: feast_contour_expert, feast_contour_custom_weights!\n\n","category":"section"},{"location":"zero_to_feast/#8)-Validating-and-Troubleshooting","page":"Zero to FeastKit","title":"8) Validating and Troubleshooting","text":"Check that the interval contains eigenvalues:\n\nusing FeastKit, LinearAlgebra\n\nA = diagm(0 => [1.0, 2.0, 3.0, 4.0])\nbounds = feast_validate_interval(A, (1.5, 3.5))\n@info \"Gershgorin bounds\" bounds\n\nCommon issues and fixes:\n\nFound zero eigenvalues: widen the interval or increase M0.\nSlow/No convergence: increase fpm[2], adjust fpm[3], or use different integration type.\nGeneralized problem instability: ensure B is SPD for symmetric problems.\nMatrix-free solves: ensure matvec is correct and efficient; tune iterative solver options.\n\n","category":"section"},{"location":"zero_to_feast/#9)-Parallel-Backends","page":"Zero to FeastKit","title":"9) Parallel Backends","text":"FeastKit supports threads, distributed workers, and MPI (if available):\n\nusing FeastKit\ncap = feast_parallel_capabilities()\n@info \"Parallel capabilities\" cap\n\n# Use threads if available\nres_t = feast(A, (Emin, Emax), M0=20, parallel=:threads)\n\n# Or use distributed workers (addprocs required)\n# res_d = feast(A, (Emin, Emax), M0=20, parallel=:distributed)\n\nMPI paths require MPI.jl and a proper MPI environment.\n\n","category":"section"},{"location":"zero_to_feast/#10)-Quick-Checklist","page":"Zero to FeastKit","title":"10) Quick Checklist","text":"[ ] Install and verify FeastKit\n[ ] Choose search region and M0\n[ ] Start dense/sparse; switch to matrix-free if needed\n[ ] Tune parameters (fpm) for accuracy/performance\n[ ] Scale up with threads/distributed/MPI\n[ ] Validate results and residuals\n\n","category":"section"},{"location":"zero_to_feast/#Where-to-Go-Next","page":"Zero to FeastKit","title":"Where to Go Next","text":"Getting Started: basics and common workflows\nMatrix-Free Interface: large-scale problems without assembling matrices\nCustom Contours: Gauss/Zolotarev and user-defined nodes/weights\nPerformance Guide: tuning and resource selection\n\nHappy computing!","category":"section"},{"location":"complex_eigenvalues/#Complex-Eigenvalues-(Non-Hermitian)","page":"Complex Eigenvalues","title":"Complex Eigenvalues (Non-Hermitian)","text":"For non-Hermitian problems, search in a circular region of the complex plane:\n\nusing FeastKit\nA = your_nonsymmetric_matrix()\nB = Matrix(I, size(A)...)  # identity\ncenter, radius = 1.0 + 0.5im, 2.0\nres = feast_general(A, B, center, radius, M0=20)\n\nIf you need custom contours beyond circles, see Custom Contours.","category":"section"},{"location":"testing/#Testing","page":"Testing","title":"Testing","text":"Run the package tests:\n\njulia --project -e 'using Pkg; Pkg.test()'\n\nTips:\n\nUse JULIA_DEPOT_PATH=$PWD/.julia to keep artifacts local to the repo\nPrefer small, focused tests that run quickly","category":"section"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented here.\n\n1.0.0 — Initial release.","category":"section"},{"location":"matrix_free_interface/#Matrix-Free-FeastKit-Interface","page":"Matrix-Free Interface","title":"Matrix-Free FeastKit Interface","text":"The matrix-free interface allows you to use FeastKit without explicitly storing matrices, making it ideal for large-scale problems where memory is limited or when matrices are too expensive to construct.","category":"section"},{"location":"matrix_free_interface/#Overview","page":"Matrix-Free Interface","title":"Overview","text":"Instead of providing explicit matrices A and B, you provide functions that compute matrix-vector products:\n\nA_mul!(y, x) computes y = A*x\nB_mul!(y, x) computes y = B*x\nlinear_solver(Y, z, X) solves (z*B - A)*Y = X","category":"section"},{"location":"matrix_free_interface/#Matrix-Free-Operator-Types","page":"Matrix-Free Interface","title":"Matrix-Free Operator Types","text":"","category":"section"},{"location":"matrix_free_interface/#LinearOperator","page":"Matrix-Free Interface","title":"LinearOperator","text":"The main interface for defining matrix-free operators:\n\nusing FeastKit\n\n# Define matrix-vector multiplication function\nfunction A_mul!(y, x)\n    # Your custom matrix-vector product code here\n    # Example: y = A*x for some implicit matrix A\nend\n\n# Create operator\nn = 1000  # Matrix size\nA_op = LinearOperator{Float64}(A_mul!, (n, n), issymmetric=true)\n\nProperties you can specify:\n\nissymmetric=true/false: Matrix is symmetric\nishermitian=true/false: Matrix is Hermitian  \nisposdef=true/false: Matrix is positive definite","category":"section"},{"location":"matrix_free_interface/#MatrixVecFunction","page":"Matrix-Free Interface","title":"MatrixVecFunction","text":"Alternative interface for operators that need additional data:\n\nfunction A_mul!(y, op, x)\n    # Access operator data via op.data\n    mul!(y, op.data, x)\nend\n\nA_op = MatrixVecFunction{Float64}(A_mul!, (n, n), issymmetric=true)","category":"section"},{"location":"matrix_free_interface/#Basic-Usage","page":"Matrix-Free Interface","title":"Basic Usage","text":"","category":"section"},{"location":"matrix_free_interface/#Standard-Eigenvalue-Problem-(A*x-λ*x)","page":"Matrix-Free Interface","title":"Standard Eigenvalue Problem (Ax = λx)","text":"using FeastKit\n\nn = 10000\n\n# Define A*x operation\nfunction laplacian_1d!(y, x)\n    # 1D discrete Laplacian: [-1 2 -1] stencil\n    y[1] = 2*x[1] - x[2]\n    for i in 2:n-1\n        y[i] = -x[i-1] + 2*x[i] - x[i+1]\n    end  \n    y[n] = -x[n-1] + 2*x[n]\nend\n\n# Create operator\nA_op = LinearOperator{Float64}(laplacian_1d!, (n, n), issymmetric=true)\n\n# Solve eigenvalue problem\nresult = feast(A_op, (0.1, 1.0), M0=10, solver=:cg)\n\nprintln(\"Found $(result.M) eigenvalues\")\nprintln(\"Eigenvalues: $(result.lambda[1:result.M])\")","category":"section"},{"location":"matrix_free_interface/#Generalized-Eigenvalue-Problem-(A*x-λ*B*x)","page":"Matrix-Free Interface","title":"Generalized Eigenvalue Problem (Ax = λB*x)","text":"# Define both A and B operations\nfunction A_mul!(y, x)\n    # Your A*x computation\nend\n\nfunction B_mul!(y, x) \n    # Your B*x computation\nend\n\nA_op = LinearOperator{Float64}(A_mul!, (n, n), issymmetric=true)\nB_op = LinearOperator{Float64}(B_mul!, (n, n), issymmetric=true, isposdef=true)\n\nresult = feast(A_op, B_op, (emin, emax), M0=10)","category":"section"},{"location":"matrix_free_interface/#Linear-Solvers","page":"Matrix-Free Interface","title":"Linear Solvers","text":"FeastKit requires solving linear systems (z*B - A)*Y = X for various values of z. You have several options:","category":"section"},{"location":"matrix_free_interface/#Built-in-Iterative-Solvers","page":"Matrix-Free Interface","title":"Built-in Iterative Solvers","text":"# Use GMRES (default, works for general problems)\nresult = feast(A_op, B_op, interval, solver=:gmres, \n              solver_opts=(rtol=1e-6, restart=30, maxiter=1000))\n\n# Use CG (for symmetric positive definite systems)\nresult = feast(A_op, B_op, interval, solver=:cg,\n              solver_opts=(rtol=1e-8, maxiter=500))\n\n# Use BiCGSTAB(l) \nresult = feast(A_op, B_op, interval, solver=:bicgstab,\n              solver_opts=(l=2, rtol=1e-6, maxiter=800))","category":"section"},{"location":"matrix_free_interface/#Custom-Linear-Solver","page":"Matrix-Free Interface","title":"Custom Linear Solver","text":"For specialized problems, provide your own solver:\n\nfunction my_custom_solver(Y::AbstractMatrix, z::Number, X::AbstractMatrix)\n    # Solve (z*B - A)*Y = X for each column of X\n    # Store results in corresponding columns of Y\n    \n    M0 = size(X, 2)\n    for j in 1:M0\n        # Your custom solution method for column j\n        Y[:, j] = solve_linear_system(z, X[:, j])\n    end\nend\n\nresult = feast(A_op, B_op, interval, solver=my_custom_solver)","category":"section"},{"location":"matrix_free_interface/#Advanced-Features","page":"Matrix-Free Interface","title":"Advanced Features","text":"","category":"section"},{"location":"matrix_free_interface/#Custom-Contour-Integration","page":"Matrix-Free Interface","title":"Custom Contour Integration","text":"Use advanced contour integration methods from the original Fortran FEAST:\n\n# Gauss-Legendre integration (high accuracy)\ncontour = feast_contour_expert(emin, emax, 8, 0, 100)\n\n# Zolotarev integration (optimal for ellipses) \ncontour = feast_contour_expert(emin, emax, 12, 2, 100)\n\n# Custom ellipse aspect ratio (a/b = 0.5, flatter ellipse)\ncontour = feast_contour_expert(emin, emax, 10, 0, 50)","category":"section"},{"location":"matrix_free_interface/#General-(Non-Hermitian)-Problems","page":"Matrix-Free Interface","title":"General (Non-Hermitian) Problems","text":"For non-symmetric matrices with complex eigenvalues:\n\n# Complex operators\nA_op = LinearOperator{ComplexF64}(A_mul!, (n, n))\nB_op = LinearOperator{ComplexF64}(B_mul!, (n, n))\n\n# Circular search region in complex plane\ncenter = 1.0 + 0.5im\nradius = 2.0\n\nresult = feast_general(A_op, B_op, center, radius, M0=10)","category":"section"},{"location":"matrix_free_interface/#Polynomial-Eigenvalue-Problems","page":"Matrix-Free Interface","title":"Polynomial Eigenvalue Problems","text":"For polynomial eigenvalue problems P(λ)x = 0:\n\n# Define coefficient operators for P(λ) = A₀ + λ*A₁ + λ²*A₂\nA0_op = LinearOperator{ComplexF64}(A0_mul!, (n, n))\nA1_op = LinearOperator{ComplexF64}(A1_mul!, (n, n))  \nA2_op = LinearOperator{ComplexF64}(A2_mul!, (n, n))\n\ncoeffs = [A0_op, A1_op, A2_op]\n\nresult = feast_polynomial(coeffs, center, radius, M0=15)","category":"section"},{"location":"matrix_free_interface/#Complete-Examples","page":"Matrix-Free Interface","title":"Complete Examples","text":"","category":"section"},{"location":"matrix_free_interface/#2D-Discrete-Laplacian","page":"Matrix-Free Interface","title":"2D Discrete Laplacian","text":"using FeastKit\n\n# Parameters\nnx, ny = 200, 200\nn = nx * ny\nh = 1.0 / (nx + 1)\n\n# Index mapping\nidx(i, j) = (j-1) * nx + i\n\n# Matrix-free 2D Laplacian\nfunction laplacian_2d!(y, x)\n    fill!(y, 0)\n    for j in 1:ny, i in 1:nx\n        k = idx(i, j)\n        y[k] += 4 * x[k] / h^2\n        \n        # Neighbors\n        i > 1  && (y[k] -= x[idx(i-1, j)] / h^2)\n        i < nx && (y[k] -= x[idx(i+1, j)] / h^2)\n        j > 1  && (y[k] -= x[idx(i, j-1)] / h^2)\n        j < ny && (y[k] -= x[idx(i, j+1)] / h^2)\n    end\nend\n\nA_op = LinearOperator{Float64}(laplacian_2d!, (n, n), \n                              issymmetric=true, isposdef=true)\n\n# Find smallest eigenvalues\nλ_min_approx = 2π^2 * (1/nx^2 + 1/ny^2)\nresult = feast(A_op, (0.5*λ_min_approx, 2.0*λ_min_approx), \n              M0=20, solver=:cg)\n\nprintln(\"Found $(result.M) eigenvalues:\")\nfor i in 1:result.M\n    println(\"  λ[$i] = $(result.lambda[i])\")\nend","category":"section"},{"location":"matrix_free_interface/#Large-Sparse-Matrix-as-Matrix-Free","page":"Matrix-Free Interface","title":"Large Sparse Matrix as Matrix-Free","text":"Even when you have a sparse matrix, using the matrix-free interface can save memory for very large problems:\n\nusing SparseArrays\n\n# Create large sparse matrix (don't store factorizations)\nn = 100000\nA_sparse = sprand(n, n, 0.0001)  # Very sparse\nA_sparse = A_sparse + A_sparse' + 5*I  # Symmetric positive definite\n\n# Matrix-free wrapper\nA_mul!(y, x) = mul!(y, A_sparse, x)\nA_op = LinearOperator{Float64}(A_mul!, (n, n), issymmetric=true, isposdef=true)\n\n# Find largest eigenvalues\nresult = feast(A_op, (4.8, 5.2), M0=8, solver=:cg)","category":"section"},{"location":"matrix_free_interface/#Performance-Tips","page":"Matrix-Free Interface","title":"Performance Tips","text":"Choose appropriate solver: Use :cg for symmetric positive definite systems, :gmres for general problems.\nTune solver parameters: Adjust rtol, maxiter, and restart based on your problem.\nOptimize matrix-vector products: Make your A_mul! and B_mul! functions as efficient as possible.\nUse workspace reuse: For repeated solves, pre-allocate workspace:\nworkspace = allocate_matfree_workspace(Float64, n, M0)\nresult = feast_matfree_srci!(A_op, B_op, interval, M0; workspace=workspace)\nConsider integration method: Zolotarev integration often requires fewer points than Gauss-Legendre.","category":"section"},{"location":"matrix_free_interface/#Error-Handling","page":"Matrix-Free Interface","title":"Error Handling","text":"Common issues and solutions:\n\nLinear solver convergence: Increase maxiter, decrease rtol, or try different solver\nFeastKit not converging: Increase maxiter in FeastKit parameters, adjust tol \nNo eigenvalues found: Check that search interval/region contains eigenvalues\nMemory issues: Use iterative solvers, increase sparsity, consider domain decomposition","category":"section"},{"location":"matrix_free_interface/#Integration-with-Other-Packages","page":"Matrix-Free Interface","title":"Integration with Other Packages","text":"The matrix-free interface works well with:\n\nIterativeSolvers.jl: For advanced iterative methods\nLinearMaps.jl: Alternative operator interface\nKrylovKit.jl: High-performance Krylov methods  \nPreconditioners.jl: For preconditioning\nCUDA.jl: For GPU-accelerated operations\n\nExample with LinearMaps.jl:\n\nusing LinearMaps, FeastKit\n\n# Convert LinearMap to FeastKit operator\nlmap = LinearMap(your_function!, n)\nA_op = LinearOperator{Float64}((y,x) -> mul!(y, lmap, x), (n, n))\n\nresult = feast(A_op, interval)","category":"section"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"Complete reference for all FeastKit.jl functions, types, and interfaces.","category":"section"},{"location":"api_reference/#Table-of-Contents","page":"API Reference","title":"Table of Contents","text":"Main Interfaces\nMatrix-Free Interface \nContour Integration\nParallel Computing\nTypes and Structures\nUtility Functions\nError Codes\n\n","category":"section"},{"location":"api_reference/#Main-Interfaces","page":"API Reference","title":"Main Interfaces","text":"","category":"section"},{"location":"api_reference/#feast","page":"API Reference","title":"feast","text":"Main FeastKit interface for symmetric/Hermitian eigenvalue problems.\n\nfeast(A, interval; M0=10, fpm=nothing, kwargs...)\nfeast(A, B, interval; M0=10, fpm=nothing, kwargs...)\n\nArguments:\n\nA::AbstractMatrix: System matrix (symmetric/Hermitian)\nB::AbstractMatrix: Mass matrix (optional, defaults to identity)\ninterval::Tuple{Real,Real}: Search interval (Emin, Emax)\n\nKeyword Arguments:\n\nM0::Int=10: Maximum number of eigenvalues to find\nfpm::Vector{Int}: FeastKit parameter array (auto-initialized if nothing)\nparallel::Union{Bool,Symbol}=false: Parallelization mode\nuse_threads::Bool=true: Enable threading\ncomm: MPI communicator (if using MPI)\n\nReturns:\n\nFeastResult: Results structure with eigenvalues and eigenvectors\n\nExamples:\n\n# Standard eigenvalue problem\nresult = feast(A, (0.5, 1.5), M0=10)\n\n# Generalized eigenvalue problem  \nresult = feast(A, B, (0.1, 0.8), M0=15)\n\n# With custom parameters\nfpm = zeros(Int, 64)\nfpm[2] = 16  # 16 integration points\nresult = feast(A, (0, 1), M0=20, fpm=fpm)","category":"section"},{"location":"api_reference/#feast_general","page":"API Reference","title":"feast_general","text":"FeastKit interface for general (non-Hermitian) eigenvalue problems using circular contours.\n\nfeast_general(A, B, center, radius; M0=10, fpm=nothing)\n\nArguments:\n\nA::AbstractMatrix{Complex}: System matrix\nB::AbstractMatrix{Complex}: Mass matrix  \ncenter::Complex: Center of circular search region\nradius::Real: Radius of circular search region\n\nExamples:\n\n# Complex eigenvalue problem\nA = randn(ComplexF64, 100, 100)\nB = Matrix{ComplexF64}(I, 100, 100)\nresult = feast_general(A, B, 1.0+0.5im, 2.0, M0=10)","category":"section"},{"location":"api_reference/#feast_banded","page":"API Reference","title":"feast_banded","text":"FeastKit interface for banded matrices.\n\nfeast_banded(A, kla, interval; B=nothing, klb=0, M0=10, fpm=nothing)\n\nArguments:\n\nA::Matrix: Banded matrix in LAPACK banded format\nkla::Int: Number of super-diagonals of A\ninterval::Tuple{Real,Real}: Search interval\nB::Matrix: Banded mass matrix (optional)\nklb::Int: Number of super-diagonals of B\n\n","category":"section"},{"location":"api_reference/#Matrix-Free-Interface","page":"API Reference","title":"Matrix-Free Interface","text":"","category":"section"},{"location":"api_reference/#LinearOperator","page":"API Reference","title":"LinearOperator","text":"Matrix-free operator type for large-scale problems.\n\nLinearOperator{T}(A_mul!, size; kwargs...)\n\nArguments:\n\nA_mul!::Function: Function (y, x) -> y = A*x\nsize::Tuple{Int,Int}: Matrix dimensions\n\nKeyword Arguments:\n\nissymmetric::Bool=false: Matrix is symmetric\nishermitian::Bool=false: Matrix is Hermitian\nisposdef::Bool=false: Matrix is positive definite\nAt_mul!::Function: Function for A'*x (optional)\nAc_mul!::Function: Function for A†*x (optional)\n\nExamples:\n\n# Define matrix-vector multiplication\nfunction A_mul!(y, x)\n    # Tridiagonal: [-1 2 -1] stencil\n    n = length(x)\n    y[1] = 2*x[1] - x[2]\n    for i in 2:n-1\n        y[i] = -x[i-1] + 2*x[i] - x[i+1]\n    end\n    y[n] = -x[n-1] + 2*x[n]\nend\n\n# Create operator\nA_op = LinearOperator{Float64}(A_mul!, (n, n), issymmetric=true)\n\n# Use with FeastKit\nresult = feast(A_op, (0.5, 1.5), M0=10, solver=:cg)","category":"section"},{"location":"api_reference/#MatrixVecFunction","page":"API Reference","title":"MatrixVecFunction","text":"Alternative matrix-free operator with data storage.\n\nMatrixVecFunction{T}(mul!, size; kwargs...)\n\nArguments:\n\nmul!::Function: Function (y, op, x) -> y = op*x  \nsize::Tuple{Int,Int}: Matrix dimensions","category":"section"},{"location":"api_reference/#feast-(Matrix-Free)","page":"API Reference","title":"feast (Matrix-Free)","text":"Matrix-free FeastKit interfaces.\n\n# Symmetric/Hermitian problems\nfeast(A_op::MatrixFreeOperator, interval; kwargs...)\nfeast(A_op::MatrixFreeOperator, B_op::MatrixFreeOperator, interval; kwargs...)\n\n# General problems  \nfeast_general(A_op::MatrixFreeOperator{Complex}, B_op, center, radius; kwargs...)\n\nAdditional Keyword Arguments:\n\nsolver::Union{Symbol,Function}=:gmres: Linear solver type\nsolver_opts::NamedTuple: Solver-specific options\ntol::Real=1e-12: Convergence tolerance\nmaxiter::Int=20: Maximum refinement iterations\n\nSolvers:\n\n:cg: Conjugate Gradient (symmetric positive definite)\n:gmres: Generalized Minimal Residual (general)\n:bicgstab: BiConjugate Gradient Stabilized\nCustom function: (Y, z, X) -> solve (z*B - A)*Y = X","category":"section"},{"location":"api_reference/#create*iterative*solver","page":"API Reference","title":"createiterativesolver","text":"Create iterative linear solver for matrix-free FeastKit.\n\ncreate_iterative_solver(A_op, B_op, solver_type=:gmres; kwargs...)\n\nKeyword Arguments:\n\nrtol::Float64=1e-6: Relative tolerance\nmaxiter::Int=1000: Maximum iterations  \nrestart::Int=30: GMRES restart parameter\npreconditioner: Preconditioner (optional)\n\n","category":"section"},{"location":"api_reference/#Contour-Integration","page":"API Reference","title":"Contour Integration","text":"","category":"section"},{"location":"api_reference/#feast_contour","page":"API Reference","title":"feast_contour","text":"Generate elliptical integration contour for real intervals.\n\nfeast_contour(Emin, Emax, fpm)\n\nReturns:\n\nFeastContour: Contour with nodes Zne and weights Wne","category":"section"},{"location":"api_reference/#feast*contour*expert","page":"API Reference","title":"feastcontourexpert","text":"Advanced contour generation with full control.\n\nfeast_contour_expert(Emin, Emax, ne, integration_type=0, ellipse_ratio=100)\n\nArguments:\n\nEmin, Emax::Real: Interval bounds\nne::Int: Number of integration points\nintegration_type::Int: 0=Gauss-Legendre, 1=Trapezoidal, 2=Zolotarev\nellipse_ratio::Int: Aspect ratio a/b × 100 (100 = circle)\n\nExamples:\n\n# High-accuracy Gauss-Legendre with 16 points\ncontour = feast_contour_expert(-1.0, 1.0, 16, 0, 100)\n\n# Zolotarev integration (optimal for ellipses)  \ncontour = feast_contour_expert(0.0, 2.0, 12, 2, 100)\n\n# Flat ellipse (aspect ratio 0.5)\ncontour = feast_contour_expert(-1.0, 1.0, 10, 0, 50)","category":"section"},{"location":"api_reference/#feast_gcontour","page":"API Reference","title":"feast_gcontour","text":"Generate circular contour for general problems.\n\nfeast_gcontour(center, radius, fpm)","category":"section"},{"location":"api_reference/#feast*contour*custom_weights!","page":"API Reference","title":"feastcontourcustom_weights!","text":"Custom contour with user-provided nodes and weights.\n\nfeast_contour_custom_weights!(Zne, Wne)\n\nArguments:\n\nZne::Vector{Complex}: Integration nodes\nWne::Vector{Complex}: Integration weights (modified in-place)","category":"section"},{"location":"api_reference/#feast*rational*expert","page":"API Reference","title":"feastrationalexpert","text":"Evaluate rational function using custom contour.\n\nfeast_rational_expert(Zne, Wne, lambda)\n\nArguments:\n\nZne::Vector{Complex}: Integration nodes\nWne::Vector{Complex}: Integration weights  \nlambda::Vector: Eigenvalues to evaluate\n\nReturns:\n\nVector: Rational function values (≈1 inside contour, ≈0 outside)\n\n","category":"section"},{"location":"api_reference/#Parallel-Computing","page":"API Reference","title":"Parallel Computing","text":"","category":"section"},{"location":"api_reference/#feast-(Parallel)","page":"API Reference","title":"feast (Parallel)","text":"Parallel FeastKit interfaces.\n\nfeast(A, interval; parallel=:mpi, comm=MPI.COMM_WORLD, kwargs...)\n\nParallel Options:\n\nparallel=false: Serial execution\nparallel=:threads: Shared-memory threading  \nparallel=:mpi: MPI parallelization\nparallel=:hybrid: MPI + threads","category":"section"},{"location":"api_reference/#mpi_feast","page":"API Reference","title":"mpi_feast","text":"Direct MPI interface.\n\nmpi_feast(A, B, interval, comm; kwargs...)","category":"section"},{"location":"api_reference/#ParallelFeastState","page":"API Reference","title":"ParallelFeastState","text":"State structure for parallel FeastKit calculations.\n\nstate = ParallelFeastState(comm, A, B, interval, M0)\nresult = feast_parallel!(state)\n\n","category":"section"},{"location":"api_reference/#Types-and-Structures","page":"API Reference","title":"Types and Structures","text":"","category":"section"},{"location":"api_reference/#FeastResult","page":"API Reference","title":"FeastResult","text":"Result structure returned by FeastKit calculations.\n\nstruct FeastResult{T<:Real, VT}\n    lambda::Vector{T}    # Eigenvalues found\n    q::Matrix{VT}        # Eigenvectors (columns)\n    M::Int               # Number of eigenvalues found\n    res::Vector{T}       # Individual residuals\n    info::Int            # Status code (0 = success)\n    epsout::T           # Final residual\n    loop::Int           # Refinement iterations used\nend\n\nAccess patterns:\n\nresult = feast(A, (0, 1), M0=10)\n\neigenvalues = result.lambda[1:result.M]\neigenvectors = result.q[:, 1:result.M]  \nsuccess = (result.info == 0)","category":"section"},{"location":"api_reference/#FeastContour","page":"API Reference","title":"FeastContour","text":"Integration contour structure.\n\nstruct FeastContour{T<:Real}\n    Zne::Vector{Complex{T}}  # Integration nodes\n    Wne::Vector{Complex{T}}  # Integration weights\nend","category":"section"},{"location":"api_reference/#FeastParameters","page":"API Reference","title":"FeastParameters","text":"FeastKit parameter structure.\n\nstruct FeastParameters\n    fpm::Vector{Int}  # 64-element parameter array\nend","category":"section"},{"location":"api_reference/#MatrixFreeOperator","page":"API Reference","title":"MatrixFreeOperator","text":"Abstract base type for matrix-free operators.\n\nabstract type MatrixFreeOperator{T} end\n\nConcrete types:\n\nLinearOperator{T}\nMatrixVecFunction{T}\n\n","category":"section"},{"location":"api_reference/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api_reference/#feastinit!","page":"API Reference","title":"feastinit!","text":"Initialize FeastKit parameter array.\n\nfeastinit!(fpm::Vector{Int})\n\nSets default values for all FeastKit parameters.","category":"section"},{"location":"api_reference/#feastdefault!","page":"API Reference","title":"feastdefault!","text":"Reset FeastKit parameters to defaults.\n\nfeastdefault!(fpm::Vector{Int})","category":"section"},{"location":"api_reference/#feast*set*defaults!","page":"API Reference","title":"feastsetdefaults!","text":"Set common FeastKit parameters with user-friendly names.\n\nfeast_set_defaults!(fpm; print_level=1, integration_points=8, \n                   tolerance_exp=12, max_refinement=20)","category":"section"},{"location":"api_reference/#feast*validate*interval","page":"API Reference","title":"feastvalidateinterval","text":"Validate search interval and estimate eigenvalue bounds.\n\nfeast_validate_interval(A, interval)\n\nReturns:\n\nTuple{Real,Real}: Estimated eigenvalue bounds using Gershgorin circles","category":"section"},{"location":"api_reference/#feast_summary","page":"API Reference","title":"feast_summary","text":"Print summary of FeastKit results.\n\nfeast_summary(result::FeastResult)","category":"section"},{"location":"api_reference/#eigvals_feast","page":"API Reference","title":"eigvals_feast","text":"Extract only eigenvalues from FeastKit calculation.\n\neigvals_feast(A, interval; kwargs...)\n\nReturns:\n\nVector: Eigenvalues found","category":"section"},{"location":"api_reference/#eigen_feast","page":"API Reference","title":"eigen_feast","text":"Return Eigen object from FeastKit calculation.\n\neigen_feast(A, interval; kwargs...)\n\nReturns:\n\nEigen: LinearAlgebra.Eigen object with values and vectors","category":"section"},{"location":"api_reference/#allocate*matfree*workspace","page":"API Reference","title":"allocatematfreeworkspace","text":"Allocate workspace for matrix-free operations.\n\nallocate_matfree_workspace(T, N, M0)\n\nArguments:\n\nT::Type: Element type (Float64, ComplexF64, etc.)\nN::Int: Matrix size\nM0::Int: Maximum eigenvalues\n\n","category":"section"},{"location":"api_reference/#Error-Codes","page":"API Reference","title":"Error Codes","text":"FeastKit functions return status codes in result.info:\n\nCode Name Description\n0 Feast_SUCCESS Success\n1 Feast_ERROR_N Invalid matrix size N\n2 Feast_ERROR_M0 Invalid M0 parameter\n3 Feast_ERROR_EMIN_EMAX Invalid search interval\n4 Feast_ERROR_EMID_R Invalid center/radius for complex problems\n5 Feast_ERROR_NO_CONVERGENCE No convergence achieved\n6 Feast_ERROR_MEMORY Memory allocation failed\n7 Feast_ERROR_INTERNAL Internal error\n8 Feast_ERROR_LAPACK Linear algebra error\n9 Feast_ERROR_FPM Invalid FeastKit parameters\n\nError handling:\n\nresult = feast(A, interval)\n\nif result.info != 0\n    error_name = [\"Feast_SUCCESS\", \"Feast_ERROR_N\", \"Feast_ERROR_M0\", \n                  \"Feast_ERROR_EMIN_EMAX\", \"Feast_ERROR_EMID_R\",\n                  \"Feast_ERROR_NO_CONVERGENCE\", \"Feast_ERROR_MEMORY\",\n                  \"Feast_ERROR_INTERNAL\", \"Feast_ERROR_LAPACK\", \n                  \"Feast_ERROR_FPM\"][result.info + 1]\n    @warn \"FeastKit failed with $error_name\"\nend\n\n","category":"section"},{"location":"api_reference/#Parameter-Reference","page":"API Reference","title":"Parameter Reference","text":"The fpm parameter array controls FeastKit behavior:\n\nIndex Parameter Default Description\nfpm[1] Print level 1 0=silent, 1=summary, 2=detailed\nfpm[2] Integration points 8 Number of contour points\nfpm[3] Tolerance exponent 12 Convergence: 10^(-fpm[3])\nfpm[4] Max iterations 20 Maximum refinement loops\nfpm[5] Initial subspace 0 0=random, 1=user-provided\nfpm[16] Integration type 0 0=Gauss, 1=Trapezoidal, 2=Zolotarev\nfpm[18] Ellipse ratio 100 Aspect ratio × 100\n\nSetting parameters:\n\nfpm = zeros(Int, 64)\nfeastinit!(fpm)\n\nfpm[1] = 2      # Detailed output\nfpm[2] = 16     # 16 integration points  \nfpm[3] = 14     # High precision (10^-14)\nfpm[16] = 2     # Zolotarev integration\n\nresult = feast(A, interval, M0=10, fpm=fpm)\n\n","category":"section"},{"location":"api_reference/#Performance-Guidelines","page":"API Reference","title":"Performance Guidelines","text":"","category":"section"},{"location":"api_reference/#Memory-Usage","page":"API Reference","title":"Memory Usage","text":"Problem Type Memory per Eigenvalue Total Memory\nDense N×N ~16N bytes ~16NM bytes\nSparse N×N ~16N bytes ~16NM bytes\nMatrix-free N×N ~16N bytes ~16NM bytes","category":"section"},{"location":"api_reference/#Recommended-Parameters","page":"API Reference","title":"Recommended Parameters","text":"Problem Size M0 Integration Points Tolerance\nN < 1,000 10-20 8-12 1e-12\n1,000 < N < 10,000 10-30 8-16 1e-10\n10,000 < N < 100,000 10-50 12-20 1e-8\nN > 100,000 10-100 16-32 1e-6","category":"section"},{"location":"api_reference/#Solver-Selection","page":"API Reference","title":"Solver Selection","text":"Problem Type Recommended Solver Options\nSymmetric positive definite :cg rtol=1e-8\nSymmetric indefinite :gmres restart=30\nGeneral non-symmetric :gmres restart=50, rtol=1e-6\nWell-conditioned :bicgstab l=2\n\n\n\n<div align=\"center\">   <p><strong>Complete API documentation for FeastKit.jl</strong></p>   ← Getting Started | Examples </div>","category":"section"},{"location":"api_reference/#FeastKit.LinearOperator","page":"API Reference","title":"FeastKit.LinearOperator","text":"LinearOperator{T}\n\nMatrix-free operator that supports multiple operations.\n\nFields\n\nA_mul!: Function (y, x) -> y = A*x\nAt_mul!: Function (y, x) -> y = A'*x (optional)\nAc_mul!: Function (y, x) -> y = A†*x (optional)\nsolve!: Function (y, z, x) -> y = (z*I - A)\\x (linear solver)\nsize: Operator size\nissymmetric, ishermitian, isposdef: Properties\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#FeastKit.MatrixVecFunction","page":"API Reference","title":"FeastKit.MatrixVecFunction","text":"MatrixVecFunction{T}\n\nMatrix-free operator defined by a matrix-vector multiplication function.\n\nFields\n\nmul!: Function with signature mul!(y, op, x) that computes y = op * x\nsize: Size of the operator as (m, n)\nissymmetric: Whether the operator is symmetric\nishermitian: Whether the operator is Hermitian  \nisposdef: Whether the operator is positive definite\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#FeastKit.MatrixFreeOperator","page":"API Reference","title":"FeastKit.MatrixFreeOperator","text":"MatrixFreeOperator{T}\n\nAbstract type for matrix-free operators.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#FeastKit.feast","page":"API Reference","title":"FeastKit.feast","text":"feast(A_op, B_op, interval; kwargs...)\n\nHigh-level matrix-free Feast interface for symmetric/Hermitian problems.\n\nArguments\n\nA_op: Matrix-free operator for A\nB_op: Matrix-free operator for B\ninterval: Search interval (Emin, Emax) for real problems\n\nKeyword Arguments\n\nM0: Maximum number of eigenvalues (default: 10)\nsolver: Linear solver (:gmres, :bicgstab, :cg, or custom function)\nsolver_opts: Options for iterative solver\nfpm: Feast parameters\ntol: Convergence tolerance\nmaxiter: Maximum refinement iterations\n\nReturns\n\nFeastResult with eigenvalues and eigenvectors\n\n\n\n\n\nfeast(A_op, interval; kwargs...)\n\nMatrix-free Feast for standard eigenvalue problems (B = I).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_general","page":"API Reference","title":"FeastKit.feast_general","text":"feast_general(A_op, B_op, center, radius; kwargs...)\n\nMatrix-free Feast for general (non-Hermitian) eigenvalue problems.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_polynomial","page":"API Reference","title":"FeastKit.feast_polynomial","text":"feast_polynomial(coeffs_ops, center, radius; kwargs...)\n\nMatrix-free Feast for polynomial eigenvalue problems.\n\nSolves the polynomial eigenvalue problem P(λ)x = 0 where: P(λ) = coeffsops[1] + λ*coeffsops[2] + λ²coeffs_ops[3] + ... + λᵈcoeffs_ops[d+1]\n\nThe polynomial is linearized using companion matrices to form a generalized  eigenvalue problem (A - λB)y = 0 of size (dN × dN), where y = [x; λx; λ²x; ...; λᵈ⁻¹x].\n\nArguments\n\ncoeffs_ops: Vector of matrix operators [C₀, C₁, C₂, ..., Cᵈ] where P(λ) = Σᵢ λⁱCᵢ\ncenter: Center of circular search region in complex plane\nradius: Radius of circular search region\nM0: Maximum number of eigenvalues to find\nsolver: Linear solver type or custom function\nkwargs: Additional options passed to feast_general\n\nReturns\n\nFeastResult with eigenvalues λ and corresponding eigenvectors x (first N components of full eigenvector)\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_matfree_srci!","page":"API Reference","title":"FeastKit.feast_matfree_srci!","text":"feast_matfree_srci!(A_op, B_op, interval, M0; kwargs...)\n\nMatrix-free Feast RCI for real symmetric eigenvalue problems.\n\nArguments\n\nA_op: Matrix-free operator for A\nB_op: Matrix-free operator for B  \ninterval: Search interval (Emin, Emax)\nM0: Maximum number of eigenvalues to find\n\nKeyword Arguments\n\nfpm: Feast parameters vector\nlinear_solver: Function (y, z, X) -> Y where Y = (z*B - A)\\X\nworkspace: Pre-allocated workspace matrices\nmaxiter: Maximum refinement iterations\ntol: Convergence tolerance\n\nReturns\n\nFeastResult with eigenvalues and eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_matfree_grci!","page":"API Reference","title":"FeastKit.feast_matfree_grci!","text":"feast_matfree_grci!(A_op, B_op, center, radius, M0; kwargs...)\n\nMatrix-free Feast RCI for general (non-Hermitian) eigenvalue problems.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.allocate_matfree_workspace","page":"API Reference","title":"FeastKit.allocate_matfree_workspace","text":"allocate_matfree_workspace(T, N, M0)\n\nAllocate workspace arrays for matrix-free Feast operations.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.create_iterative_solver","page":"API Reference","title":"FeastKit.create_iterative_solver","text":"create_iterative_solver(A_op, B_op, solver_type=:gmres; kwargs...)\n\nCreate iterative linear solver for matrix-free Feast.\n\nArguments\n\nA_op, B_op: Matrix-free operators\nsolver_type: :gmres, :bicgstab, :cg, etc.\nkwargs: Options passed to iterative solver\n\nReturns\n\nFunction (Y, z, X) -> solve (z*B - A) * Y = X\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.create_direct_solver","page":"API Reference","title":"FeastKit.create_direct_solver","text":"create_direct_solver(A_op, B_op; factorization=:lu)\n\nCreate direct linear solver using sparse factorization. Only works if operators can be converted to sparse matrices.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.validate_companion_matrices","page":"API Reference","title":"FeastKit.validate_companion_matrices","text":"validate_companion_matrices(A_companion_mul!, B_companion_mul!, coeffs_ops, test_lambda, test_x)\n\nValidate that the companion matrices correctly linearize the polynomial eigenvalue problem.\n\nTests that if P(λ)x = 0, then (A - λB)y = 0 where y = [x; λx; λ²x; ...; λᵈ⁻¹x].\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_contour_expert","page":"API Reference","title":"FeastKit.feast_contour_expert","text":"feast_contour_expert(Emin, Emax, ne, integration_type, ellipse_ratio)\n\nGenerate Feast integration contour with expert-level control matching original Fortran implementation.\n\nArguments\n\nEmin, Emax: Search interval bounds\nne: Number of integration points (half-contour)\nintegration_type: 0=Gauss-Legendre, 1=Trapezoidal, 2=Zolotarev  \nellipse_ratio: Aspect ratio a/b * 100 (100 = circle)\n\nReturns\n\nFeastContour with integration nodes and weights\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_contour_custom_weights!","page":"API Reference","title":"FeastKit.feast_contour_custom_weights!","text":"feast_contour_custom_weights!(Zne, Wne)\n\nCustom contour integration with user-provided nodes and weights. Follows the Fortran expert interface pattern.\n\nArguments\n\nZne: Complex integration nodes\nWne: Complex integration weights (modified in-place)\n\nReturns\n\nFeastContour using provided nodes and computed/modified weights\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_rational_expert","page":"API Reference","title":"FeastKit.feast_rational_expert","text":"feast_rationalx(Zne, Wne, lambda)\n\nCompute rational function values using custom integration nodes and weights. Direct translation of dfeast_rationalx from Fortran.\n\nFor eigenvalues inside the contour, the rational function returns ≈1. For eigenvalues outside, it returns ≈0.\n\nArguments\n\nZne: Integration nodes (half-contour)\nWne: Integration weights (half-contour)\nlambda: Real eigenvalues to evaluate\n\nReturns\n\nVector of rational function values\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_rational","page":"API Reference","title":"FeastKit.feast_rational","text":"feast_rational(Emin, Emax, fpm, lambda)\n\nCompute rational function values for real eigenvalues using default ellipsoid contour. Direct translation of dfeast_rational from Fortran.\n\nArguments\n\nEmin, Emax: Search interval bounds\nfpm: FEAST parameters (fpm[2]=nodes, fpm[16]=integration type, fpm[18]=aspect ratio)\nlambda: Real eigenvalues to evaluate\n\nReturns\n\nVector of rational function values\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_rationalx","page":"API Reference","title":"FeastKit.feast_rationalx","text":"feast_rationalx(Zne, Wne, lambda)\n\nCompute rational function values using custom integration nodes and weights. Direct translation of dfeast_rationalx from Fortran.\n\nFor eigenvalues inside the contour, the rational function returns ≈1. For eigenvalues outside, it returns ≈0.\n\nArguments\n\nZne: Integration nodes (half-contour)\nWne: Integration weights (half-contour)\nlambda: Real eigenvalues to evaluate\n\nReturns\n\nVector of rational function values\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_grational","page":"API Reference","title":"FeastKit.feast_grational","text":"feast_grational(Emid, r, fpm, lambda)\n\nCompute rational function values for complex eigenvalues using default ellipsoid contour. Direct translation of zfeast_grational from Fortran.\n\nArguments\n\nEmid: Center of search region (complex)\nr: Radius of search region\nfpm: FEAST parameters (fpm[8]=nodes, fpm[16]=integration type, etc.)\nlambda: Complex eigenvalues to evaluate\n\nReturns\n\nVector of complex rational function values\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.feast_grationalx","page":"API Reference","title":"FeastKit.feast_grationalx","text":"feast_grationalx(Zne, Wne, lambda)\n\nCompute rational function values for complex eigenvalues using custom contour. Direct translation of zfeast_grationalx from Fortran.\n\nArguments\n\nZne: Integration nodes (full contour)\nWne: Integration weights (full contour)\nlambda: Complex eigenvalues to evaluate\n\nReturns\n\nVector of complex rational function values\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#FeastKit.pfeast_show_distribution","page":"API Reference","title":"FeastKit.pfeast_show_distribution","text":"pfeast_show_distribution(ne::Int; use_threads::Bool=true)\n\nDisplay how contour points would be distributed across processors/threads.\n\nArguments\n\nne::Int: Number of contour points (integration nodes)\nuse_threads::Bool: If true, show thread distribution; if false, show worker distribution\n\n\n\n\n\n","category":"function"},{"location":"custom_contours/#Custom-Contour-Integration","page":"Custom Contours","title":"Custom Contour Integration","text":"Advanced guide to customizing FeastKit's contour integration for optimal performance and accuracy.","category":"section"},{"location":"custom_contours/#Table-of-Contents","page":"Custom Contours","title":"Table of Contents","text":"Contour Integration Theory\nBuilt-in Integration Methods  \nCustom Contour Design\nAdvanced Applications\nTroubleshooting Contour Issues\n\n","category":"section"},{"location":"custom_contours/#Contour-Integration-Theory","page":"Custom Contours","title":"Contour Integration Theory","text":"","category":"section"},{"location":"custom_contours/#Mathematical-Foundation","page":"Custom Contours","title":"Mathematical Foundation","text":"The FEAST algorithm uses contour integration to compute spectral projectors. For a matrix A with eigenvalues λᵢ and eigenvectors xᵢ, the spectral projector is:\n\nP = frac12pi i oint_Gamma (zmathbfI - mathbfA)^-1 dz\n\nWhere Γ is a contour enclosing the eigenvalues of interest.","category":"section"},{"location":"custom_contours/#Moment-Based-Approach","page":"Custom Contours","title":"Moment-Based Approach","text":"FeastKit computes moments of the spectral projector:\n\nmathbfS_k = frac12pi i oint_Gamma z^k (zmathbfB - mathbfA)^-1 mathbfQ dz\n\nThe numerical integration becomes:\n\nmathbfS_k approx sum_e=1^n_e w_e z_e^k (z_emathbfB - mathbfA)^-1 mathbfQ\n\nnote: Key Insight\nThe quality of eigenvalue extraction depends critically on:Contour placement: Must enclose target eigenvalues\nIntegration accuracy: Affects moment computation quality  \nNode distribution: Should resolve eigenvalue clustering\n\n","category":"section"},{"location":"custom_contours/#Built-in-Integration-Methods","page":"Custom Contours","title":"Built-in Integration Methods","text":"","category":"section"},{"location":"custom_contours/#Gauss-Legendre-Integration","page":"Custom Contours","title":"Gauss-Legendre Integration","text":"Best for: High accuracy with minimal points, smooth integrands\n\nusing FeastKit\n\n# High-accuracy Gauss-Legendre with 16 points\ncontour = feast_contour_expert(-1.0, 1.0, 16, 0, 100)\n\nprintln(\"Gauss-Legendre contour:\")\nprintln(\"Nodes: \", contour.Zne[1:5])  # Show first 5 nodes\nprintln(\"Weights: \", contour.Wne[1:5]) # Show first 5 weights\n\nAdvantages:\n\nHighest accuracy per integration point\nOptimal for smooth problems\nWell-established theory\n\nDisadvantages:  \n\nPoints not uniformly distributed\nMay miss isolated eigenvalues","category":"section"},{"location":"custom_contours/#Trapezoidal-Rule-Integration","page":"Custom Contours","title":"Trapezoidal Rule Integration","text":"Best for: Robust integration, debugging, educational purposes\n\n# Trapezoidal rule with 12 points\ncontour = feast_contour_expert(-2.0, 2.0, 12, 1, 100)\n\n# Visualize uniform node distribution\nθ = [angle(z) for z in contour.Zne]\nprintln(\"Angles: \", sort(θ))  # Should be uniformly spaced\n\nAdvantages:\n\nUniformly distributed points\nSimple and robust\nGood for debugging\n\nDisadvantages:\n\nLower accuracy per point\nRequires more points for precision","category":"section"},{"location":"custom_contours/#Zolotarev-Integration","page":"Custom Contours","title":"Zolotarev Integration","text":"Best for: Elliptical domains, clustered eigenvalues\n\n# Zolotarev integration (optimal for ellipses)\ncontour = feast_contour_expert(0.0, 4.0, 12, 2, 100)\n\nprintln(\"Zolotarev contour characteristics:\")\nprintln(\"Optimized for elliptical regions\")\nprintln(\"Excellent for clustered eigenvalues\")\n\nAdvantages:\n\nTheoretically optimal for ellipses  \nExcellent for clustered eigenvalues\nAdaptive node placement\n\nDisadvantages:\n\nMore complex implementation\nProblem-specific optimization\n\n","category":"section"},{"location":"custom_contours/#Custom-Contour-Design","page":"Custom Contours","title":"Custom Contour Design","text":"","category":"section"},{"location":"custom_contours/#Designing-Your-Own-Contour","page":"Custom Contours","title":"Designing Your Own Contour","text":"using FeastKit, LinearAlgebra\n\nfunction create_rectangular_contour(xmin, xmax, ymin, ymax, nx, ny)\n    \"\"\"\n    Create rectangular contour for eigenvalues in complex rectangle.\n    \n    Parameters:\n    - xmin, xmax: Real axis bounds\n    - ymin, ymax: Imaginary axis bounds  \n    - nx, ny: Number of points on horizontal/vertical segments\n    \"\"\"\n    \n    # Bottom edge: xmin to xmax\n    bottom_x = range(xmin, xmax, length=nx)\n    bottom_nodes = [x + im*ymin for x in bottom_x]\n    bottom_weights = fill((xmax - xmin) / nx, nx)\n    \n    # Right edge: ymin to ymax  \n    right_y = range(ymin, ymax, length=ny)[2:end] # Skip corner\n    right_nodes = [xmax + im*y for y in right_y]\n    right_weights = fill(im * (ymax - ymin) / ny, ny-1)\n    \n    # Top edge: xmax to xmin (reverse direction)\n    top_x = range(xmax, xmin, length=nx)[2:end] # Skip corner\n    top_nodes = [x + im*ymax for x in top_x] \n    top_weights = fill(-(xmax - xmin) / nx, nx-1)\n    \n    # Left edge: ymax to ymin (reverse direction)\n    left_y = range(ymax, ymin, length=ny)[2:end-1] # Skip corners\n    left_nodes = [xmin + im*y for y in left_y]\n    left_weights = fill(-im * (ymax - ymin) / ny, ny-2)\n    \n    # Combine all segments\n    all_nodes = vcat(bottom_nodes, right_nodes, top_nodes, left_nodes)\n    all_weights = vcat(bottom_weights, right_weights, top_weights, left_weights)\n    \n    return all_nodes, all_weights\nend\n\n# Example: Rectangle around complex eigenvalues\nnodes, weights = create_rectangular_contour(-1, 3, -2, 2, 20, 16)\nprintln(\"Created rectangular contour with $(length(nodes)) points\")\n\n# Use with FeastKit\ncontour = feast_contour_custom_weights!(nodes, weights)","category":"section"},{"location":"custom_contours/#Circular-Contour-for-Complex-Eigenvalues","page":"Custom Contours","title":"Circular Contour for Complex Eigenvalues","text":"function create_circular_contour(center, radius, n_points)\n    \"\"\"\n    Create circular contour for general eigenvalue problems.\n    \"\"\"\n    θ = range(0, 2π, length=n_points+1)[1:end-1]  # Exclude 2π (same as 0)\n    \n    nodes = [center + radius * exp(im * θᵢ) for θᵢ in θ]\n    weights = [im * radius * exp(im * θᵢ) * (2π / n_points) for θᵢ in θ]\n    \n    return nodes, weights\nend\n\n# Example usage\ncenter = 1.0 + 0.5im  \nradius = 2.0\nnodes, weights = create_circular_contour(center, radius, 16)\n\ncontour = feast_contour_custom_weights!(nodes, weights)","category":"section"},{"location":"custom_contours/#Adaptive-Contour-Generation","page":"Custom Contours","title":"Adaptive Contour Generation","text":"function adaptive_elliptical_contour(Emin, Emax, eigenvalue_estimates; \n                                    min_points=8, max_points=32)\n    \"\"\"\n    Create elliptical contour adapted to eigenvalue distribution.\n    \"\"\"\n    \n    # Analyze eigenvalue clustering\n    λ_center = (Emax + Emin) / 2\n    λ_spread = (Emax - Emin) / 2\n    \n    # Estimate clustering near center\n    center_density = sum(abs.(eigenvalue_estimates .- λ_center) .< λ_spread/4)\n    total_estimates = length(eigenvalue_estimates)\n    \n    if center_density / total_estimates > 0.7\n        # High clustering near center - use more points, Zolotarev method\n        n_points = max_points\n        method = 2  # Zolotarev\n        aspect_ratio = 50  # Flatter ellipse\n        println(\"Detected clustering: using $n_points Zolotarev points\")\n        \n    elseif total_estimates < 5  \n        # Few eigenvalues - use fewer points\n        n_points = min_points\n        method = 0  # Gauss-Legendre \n        aspect_ratio = 100  # Circle\n        println(\"Few eigenvalues: using $n_points Gauss-Legendre points\")\n        \n    else\n        # Moderate distribution - standard approach\n        n_points = 16\n        method = 0  # Gauss-Legendre\n        aspect_ratio = 100\n        println(\"Standard distribution: using $n_points Gauss-Legendre points\")\n    end\n    \n    return feast_contour_expert(Emin, Emax, n_points, method, aspect_ratio)\nend\n\n# Example with eigenvalue estimates\nλ_estimates = [0.5, 0.52, 0.54, 1.8, 1.82, 1.84]  # Two clusters\ncontour = adaptive_elliptical_contour(0.0, 2.5, λ_estimates)\n\n","category":"section"},{"location":"custom_contours/#Advanced-Applications","page":"Custom Contours","title":"Advanced Applications","text":"","category":"section"},{"location":"custom_contours/#Multi-Level-Contour-Strategy","page":"Custom Contours","title":"Multi-Level Contour Strategy","text":"For problems with eigenvalues at different scales:\n\nfunction multi_level_feast(A, eigenvalue_regions; M0_per_region=10)\n    \"\"\"\n    Apply FeastKit to multiple regions with customized contours.\n    \"\"\"\n    \n    all_eigenvalues = Float64[]\n    all_eigenvectors = Matrix{Float64}(undef, size(A, 1), 0)\n    \n    for (i, (region_min, region_max, description)) in enumerate(eigenvalue_regions)\n        println(\"Processing region $i: $description\")\n        println(\"Interval: [$region_min, $region_max]\")\n        \n        # Customize contour for this region\n        width = region_max - region_min\n        \n        if width < 0.01  # Very narrow region\n            n_points = 32\n            method = 2  # Zolotarev for high precision\n        elseif width > 10  # Very wide region  \n            n_points = 12\n            method = 1  # Trapezoidal for robustness\n        else\n            n_points = 16\n            method = 0  # Gauss-Legendre standard\n        end\n        \n        contour = feast_contour_expert(region_min, region_max, \n                                     n_points, method, 100)\n        \n        # Apply FeastKit to this region\n        fpm = zeros(Int, 64)\n        feastinit!(fpm)\n        fpm[2] = n_points\n        fpm[16] = method\n        \n        result = feast(A, (region_min, region_max), M0=M0_per_region, fpm=fpm)\n        \n        println(\"Found $(result.M) eigenvalues in region $i\")\n        \n        if result.M > 0\n            append!(all_eigenvalues, result.lambda[1:result.M])\n            all_eigenvectors = hcat(all_eigenvectors, result.q[:, 1:result.M])\n        end\n    end\n    \n    # Sort combined results\n    perm = sortperm(all_eigenvalues)\n    all_eigenvalues = all_eigenvalues[perm]\n    all_eigenvectors = all_eigenvectors[:, perm]\n    \n    println(\"\\\\nTotal eigenvalues found: $(length(all_eigenvalues))\")\n    return all_eigenvalues, all_eigenvectors\nend\n\n# Example usage\nregions = [\n    (0.01, 0.1, \"Low frequency modes\"),\n    (0.8, 1.2, \"Mid-range cluster\"), \n    (4.5, 5.5, \"High frequency modes\")\n]\n\nA = create_test_matrix(1000)\neigenvalues, eigenvectors = multi_level_feast(A, regions)","category":"section"},{"location":"custom_contours/#Contour-Optimization-via-Rational-Function","page":"Custom Contours","title":"Contour Optimization via Rational Function","text":"function optimize_contour_placement(A, initial_interval, target_count; \n                                   max_iterations=5)\n    \"\"\"\n    Optimize contour placement using rational function evaluation.\n    \"\"\"\n    \n    Emin, Emax = initial_interval\n    \n    for iter in 1:max_iterations\n        println(\"Iteration $iter: interval [$Emin, $Emax]\")\n        \n        # Generate test points in current interval\n        test_points = range(Emin, Emax, length=50)\n        \n        # Evaluate rational function to estimate eigenvalue count\n        contour = feast_contour_expert(Emin, Emax, 16, 0, 100)\n        rational_values = feast_rational_expert(contour.Zne, contour.Wne, test_points)\n        \n        # Count estimated eigenvalues (rational function ≈ 1 near eigenvalues)\n        estimated_count = sum(rational_values .> 0.5)\n        \n        println(\"Estimated eigenvalues in interval: $estimated_count\")\n        println(\"Target count: $target_count\")\n        \n        if abs(estimated_count - target_count) <= 1\n            println(\"Converged to optimal interval!\")\n            break\n        end\n        \n        # Adjust interval based on estimate\n        if estimated_count > target_count\n            # Too many eigenvalues - shrink interval\n            width = Emax - Emin\n            center = (Emin + Emax) / 2\n            new_width = width * 0.8\n            Emin = center - new_width/2\n            Emax = center + new_width/2\n            \n        else  # estimated_count < target_count\n            # Too few eigenvalues - expand interval\n            width = Emax - Emin  \n            expansion = 1.2\n            Emin -= width * (expansion - 1) / 2\n            Emax += width * (expansion - 1) / 2\n        end\n    end\n    \n    return (Emin, Emax)\nend\n\n# Example usage\nA = SymTridiagonal(2.0 * ones(500), -1.0 * ones(499))\ninitial_interval = (0.5, 1.5)\noptimized_interval = optimize_contour_placement(A, initial_interval, 10)\n\nprintln(\"Optimized interval: $optimized_interval\")\n\n","category":"section"},{"location":"custom_contours/#Advanced-Contour-Shapes","page":"Custom Contours","title":"Advanced Contour Shapes","text":"","category":"section"},{"location":"custom_contours/#Star-Shaped-Contours","page":"Custom Contours","title":"Star-Shaped Contours","text":"For eigenvalues with radial distribution:\n\nfunction create_star_contour(center, radius, n_spikes, n_points_per_spike)\n    \"\"\"\n    Create star-shaped contour for eigenvalues with radial symmetry.\n    \"\"\"\n    nodes = ComplexF64[]\n    weights = ComplexF64[]\n    \n    for spike in 1:n_spikes\n        # Base angle for this spike\n        θ_base = 2π * (spike - 1) / n_spikes\n        \n        # Create points along this spike\n        for i in 1:n_points_per_spike\n            # Vary radius from center to maximum\n            r = radius * i / n_points_per_spike\n            θ = θ_base + 0.1 * sin(4π * i / n_points_per_spike)  # Add slight perturbation\n            \n            z = center + r * exp(im * θ)\n            push!(nodes, z)\n            \n            # Approximate weight (tangent direction)\n            dz_dt = (radius / n_points_per_spike) * exp(im * θ) * \n                   (1 + im * 0.4 * π * cos(4π * i / n_points_per_spike) / n_points_per_spike)\n            push!(weights, dz_dt)\n        end\n    end\n    \n    return nodes, weights\nend","category":"section"},{"location":"custom_contours/#Lens-Shaped-Contours","page":"Custom Contours","title":"Lens-Shaped Contours","text":"For eigenvalues in bimodal distributions:\n\nfunction create_lens_contour(focus1, focus2, width, n_points)\n    \"\"\"\n    Create lens-shaped (elliptical) contour between two focal points.\n    \"\"\"\n    # Ellipse parameters\n    center = (focus1 + focus2) / 2\n    focus_distance = abs(focus2 - focus1)\n    major_axis = focus_distance + width\n    minor_axis = width\n    \n    θ = range(0, 2π, length=n_points+1)[1:end-1]\n    \n    nodes = ComplexF64[]\n    weights = ComplexF64[]\n    \n    for θᵢ in θ\n        # Parametric ellipse\n        x = (major_axis/2) * cos(θᵢ)\n        y = (minor_axis/2) * sin(θᵢ)\n        \n        z = center + x + im * y\n        push!(nodes, z)\n        \n        # Derivative for weight calculation\n        dx_dθ = -(major_axis/2) * sin(θᵢ)  \n        dy_dθ = (minor_axis/2) * cos(θᵢ)\n        dz_dθ = dx_dθ + im * dy_dθ\n        \n        weight = dz_dθ * (2π / n_points)\n        push!(weights, weight)\n    end\n    \n    return nodes, weights\nend\n\n","category":"section"},{"location":"custom_contours/#Troubleshooting-Contour-Issues","page":"Custom Contours","title":"Troubleshooting Contour Issues","text":"","category":"section"},{"location":"custom_contours/#Diagnostic-Tools","page":"Custom Contours","title":"Diagnostic Tools","text":"function diagnose_contour_quality(contour, A, interval)\n    \"\"\"\n    Analyze contour quality for eigenvalue computation.\n    \"\"\"\n    \n    println(\"Contour Quality Diagnostics\")\n    println(\"=\"^40)\n    \n    Zne, Wne = contour.Zne, contour.Wne\n    n_points = length(Zne)\n    \n    # 1. Check contour closure\n    contour_sum = sum(Wne)\n    closure_error = abs(contour_sum)\n    println(\"Contour closure error: $closure_error\")\n    \n    if closure_error > 1e-12\n        @warn \"Contour may not be properly closed\"\n    end\n    \n    # 2. Check node distribution\n    min_spacing = minimum([abs(Zne[i] - Zne[j]) \n                          for i in 1:n_points for j in i+1:n_points])\n    avg_spacing = sum(abs(Zne[i+1] - Zne[i]) for i in 1:n_points-1) / (n_points-1)\n    \n    println(\"Minimum node spacing: $min_spacing\")\n    println(\"Average node spacing: $avg_spacing\")\n    \n    if min_spacing < avg_spacing * 0.1\n        @warn \"Nodes may be too close together\"\n    end\n    \n    # 3. Test integration accuracy with known function\n    # Integrate f(z) = 1 (should give 0 for closed contour)\n    integral_one = sum(Wne)\n    println(\"∮ 1 dz = $integral_one (should be ≈ 0)\")\n    \n    # 4. Estimate condition number at integration points\n    condition_numbers = Float64[]\n    for z in Zne\n        try\n            # Approximate condition number of (zI - A)\n            shift_matrix = z * I - A\n            σ_min = minimum(svdvals(shift_matrix))  # Smallest singular value\n            cond_approx = 1.0 / σ_min\n            push!(condition_numbers, cond_approx)\n        catch\n            push!(condition_numbers, Inf)\n        end\n    end\n    \n    max_cond = maximum(condition_numbers)\n    avg_cond = mean(condition_numbers)\n    \n    println(\"Max condition number: $max_cond\")\n    println(\"Average condition number: $avg_cond\") \n    \n    if max_cond > 1e12\n        @warn \"Some integration points may be too close to eigenvalues\"\n    end\n    \n    return (closure_error, min_spacing, avg_spacing, max_cond, avg_cond)\nend\n\n# Example usage\nA = randn(100, 100); A = A + A'  # Symmetric test matrix\ninterval = (-2, 2)\ncontour = feast_contour_expert(interval[1], interval[2], 16, 0, 100)\n\ndiagnostics = diagnose_contour_quality(contour, A, interval)","category":"section"},{"location":"custom_contours/#Common-Issues-and-Solutions","page":"Custom Contours","title":"Common Issues and Solutions","text":"warning: Issue: No eigenvalues found\nCauses: Contour doesn't enclose eigenvaluesSolutions:# 1. Check eigenvalue bounds\nbounds = feast_validate_interval(A, interval)\nprintln(\"Estimated bounds: $bounds\")\n\n# 2. Use wider interval\nwider_interval = (bounds[1] - 0.1, bounds[2] + 0.1)\nresult = feast(A, wider_interval)\n\n# 3. Visualize rational function\ntest_points = range(interval[1], interval[2], length=100)\nrational_vals = feast_rational_expert(contour.Zne, contour.Wne, test_points)\n# Plot rational_vals vs test_points (peaks indicate eigenvalues)\n\nwarning: Issue: Integration not converging\nCauses: Too few integration points, poor contour shapeSolutions:# 1. Increase integration points\ncontour = feast_contour_expert(interval[1], interval[2], 32, 0, 100)\n\n# 2. Use Zolotarev integration for difficult problems\ncontour = feast_contour_expert(interval[1], interval[2], 24, 2, 100)\n\n# 3. Adjust ellipse aspect ratio for eigenvalue distribution\ncontour = feast_contour_expert(interval[1], interval[2], 16, 0, 50)  # Flatter\n\nwarning: Issue: Spurious eigenvalues\nCauses: Numerical errors, ill-conditioned linear systemsSolutions:# 1. Increase precision\nfpm = zeros(Int, 64)\nfpm[3] = 14  # Higher tolerance (10^-14)\nresult = feast(A, interval, fmp=fpm)\n\n# 2. Check residuals\nfor i in 1:result.M\n    residual = norm(A * result.q[:, i] - result.lambda[i] * result.q[:, i])\n    println(\"λ[$(i)]: residual = $residual\")\nend\n\n# 3. Use iterative refinement\nfpm[4] = 50  # More refinement iterations\n\n\n\n<div align=\"center\">   <p><strong>Master advanced contour integration techniques with FeastKit.jl</strong></p>   ← Performance | API Reference → </div>","category":"section"},{"location":"license/#License","page":"License","title":"License","text":"This project is licensed under the terms specified in the repository root (LICENSE file). If not present, please add a suitable open-source license.","category":"section"},{"location":"getting_started/#Getting-Started-with-FeastKit.jl","page":"Getting Started","title":"Getting Started with FeastKit.jl","text":"This guide will get you up and running with FeastKit.jl in minutes. Whether you're new to eigenvalue problems or an experienced user, this tutorial covers everything you need to know.","category":"section"},{"location":"getting_started/#Table-of-Contents","page":"Getting Started","title":"Table of Contents","text":"Installation\nFirst Steps  \nBasic Usage Patterns\nUnderstanding Results\nCommon Workflows\nNext Steps\n\n","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"FeastKit.jl requires Julia 1.6 or later. Install Julia from julialang.org.","category":"section"},{"location":"getting_started/#Installing-FeastKit.jl","page":"Getting Started","title":"Installing FeastKit.jl","text":"# Start Julia and enter package mode with ]\njulia> ]\n\n# Install FeastKit.jl\npkg> add FeastKit\n\n# Or for the development version:\npkg> add https://github.com/your-repo/FeastKit.jl.git\n\n# Return to Julia mode\npkg> <backspace>\n\n# Load the package\njulia> using FeastKit","category":"section"},{"location":"getting_started/#Verify-Installation","page":"Getting Started","title":"Verify Installation","text":"using FeastKit, LinearAlgebra\n\n# Create a small test problem\nA = [2.0 -1.0; -1.0 2.0]\nresult = feast(A, (0.5, 2.5))\n\nprintln(\"Installation successful! Found $(result.M) eigenvalues.\")\n\nExpected output: Installation successful! Found 2 eigenvalues.\n\n","category":"section"},{"location":"getting_started/#First-Steps","page":"Getting Started","title":"First Steps","text":"","category":"section"},{"location":"getting_started/#Your-First-Eigenvalue-Calculation","page":"Getting Started","title":"Your First Eigenvalue Calculation","text":"Let's solve a classic eigenvalue problem step by step:\n\nusing FeastKit, LinearAlgebra\n\n# Step 1: Create a matrix\n# (This is a 1D discrete Laplacian - common in scientific computing)\nn = 100\nA = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\n\nprintln(\"Created $(n)×$(n) tridiagonal matrix\")\nprintln(\"Matrix A has eigenvalues between $(2-2) and $(2+2)\")\n\n# Step 2: Define search interval\n# We want eigenvalues between 0.5 and 1.5\nEmin, Emax = 0.5, 1.5\n\nprintln(\"Searching for eigenvalues in [$Emin, $Emax]\")\n\n# Step 3: Run FeastKit\n# M0 = maximum number of eigenvalues to find\nresult = feast(A, (Emin, Emax), M0=10)\n\nprintln(\"FeastKit completed:\")\nprintln(\"  Status: $(result.info == 0 ? \"Success\" : \"Error\")\")\nprintln(\"  Found: $(result.M) eigenvalues\")\nprintln(\"  Iterations: $(result.loop)\")\n\n# Step 4: Examine results\nif result.M > 0\n    println(\"\\\\nEigenvalues found:\")\n    for i in 1:result.M\n        println(\"  λ[$i] = $(result.lambda[i])\")\n    end\nend","category":"section"},{"location":"getting_started/#Understanding-What-Happened","page":"Getting Started","title":"Understanding What Happened","text":"FeastKit searched only in [0.5, 1.5] — it didn't compute all eigenvalues   Found eigenvalues efficiently using contour integration   Verified convergence — result.info == 0 means success   Provided eigenvectors too — stored in result.q\n\n","category":"section"},{"location":"getting_started/#Basic-Usage-Patterns","page":"Getting Started","title":"Basic Usage Patterns","text":"","category":"section"},{"location":"getting_started/#Pattern-1:-Standard-Eigenvalue-Problem","page":"Getting Started","title":"Pattern 1: Standard Eigenvalue Problem","text":"For problems of the form A⋅x = λ⋅x:\n\nusing FeastKit\n\n# Your matrix (dense, sparse, whatever!)\nA = your_matrix()\n\n# Find eigenvalues in an interval\nresult = feast(A, (Emin, Emax), M0=20)\n\n# Access results\neigenvalues = result.lambda[1:result.M]\neigenvectors = result.q[:, 1:result.M]\n\nReal-world example:\n\nusing FeastKit, SparseArrays\n\n# Large sparse matrix from discretized PDE\nn = 10000\nA = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))\n\n# Find the 10 smallest eigenvalues  \nresult = feast(A, (0.001, 0.1), M0=10)\nprintln(\"Smallest eigenvalues: $(result.lambda[1:result.M])\")","category":"section"},{"location":"getting_started/#Pattern-2:-Generalized-Eigenvalue-Problem","page":"Getting Started","title":"Pattern 2: Generalized Eigenvalue Problem","text":"For problems of the form A⋅x = λ⋅B⋅x:\n\n# Two matrices A and B\nA = your_stiffness_matrix()\nB = your_mass_matrix()  \n\n# Solve generalized problem\nresult = feast(A, B, (Emin, Emax), M0=15)\n\nReal-world example:\n\nusing FeastKit\n\n# Structural dynamics: K⋅u = ω²⋅M⋅u\nK = stiffness_matrix()  # Stiffness\nM = mass_matrix()       # Mass\n\n# Find natural frequencies between 10 and 100 Hz\nω²_min, ω²_max = (2π*10)^2, (2π*100)^2\nresult = feast(K, M, (ω²_min, ω²_max), M0=20)\n\nfrequencies_Hz = sqrt.(result.lambda[1:result.M]) / (2π)\nprintln(\"Natural frequencies: $frequencies_Hz Hz\")","category":"section"},{"location":"getting_started/#Pattern-3:-Matrix-Free-for-Large-Problems","page":"Getting Started","title":"Pattern 3: Matrix-Free for Large Problems","text":"When your matrix is too large to store:\n\n# Define matrix-vector multiplication\nfunction A_multiply!(y, x)\n    # Your custom A*x computation here\n    # Example: finite difference stencil\n    n = length(x)\n    y[1] = 2*x[1] - x[2]\n    for i in 2:n-1\n        y[i] = -x[i-1] + 2*x[i] - x[i+1]\n    end\n    y[n] = -x[n-1] + 2*x[n]\nend\n\n# Create operator\nn = 1_000_000  # Very large!\nA_op = LinearOperator{Float64}(A_multiply!, (n, n), issymmetric=true)\n\n# Solve exactly the same way\nresult = feast(A_op, (Emin, Emax), M0=10, solver=:cg)","category":"section"},{"location":"getting_started/#Pattern-4:-Complex-Eigenvalues","page":"Getting Started","title":"Pattern 4: Complex Eigenvalues","text":"For non-symmetric matrices with complex eigenvalues:\n\nusing FeastKit\n\n# Non-symmetric matrix\nA = your_nonsymmetric_matrix()\nB = Matrix(I, size(A)...)  # Identity matrix\n\n# Define circular search region in complex plane\ncenter = 1.0 + 0.5im     # Center point  \nradius = 2.0             # Search radius\n\nresult = feast_general(A, B, center, radius, M0=15)\n\n# Complex eigenvalues\ncomplex_eigenvalues = result.lambda[1:result.M]\n\n","category":"section"},{"location":"getting_started/#Understanding-Results","page":"Getting Started","title":"Understanding Results","text":"","category":"section"},{"location":"getting_started/#The-FeastResult-Structure","page":"Getting Started","title":"The FeastResult Structure","text":"Every FeastKit calculation returns a FeastResult with these fields:\n\nresult = feast(A, (Emin, Emax), M0=10)\n\n# Eigenvalues and eigenvectors\nresult.lambda    # Vector of eigenvalues\nresult.q         # Matrix of eigenvectors (columns)\nresult.M         # Number of eigenvalues found\n\n# Convergence information  \nresult.info      # 0 = success, >0 = error code\nresult.epsout    # Final residual\nresult.loop      # Number of refinement iterations  \nresult.res       # Individual residuals","category":"section"},{"location":"getting_started/#Interpreting-Status-Codes","page":"Getting Started","title":"Interpreting Status Codes","text":"if result.info == 0\n    println(\"Success! Found $(result.M) eigenvalues\")\nelseif result.info == 1\n    println(\"Error: Invalid matrix size\")\nelseif result.info == 2  \n    println(\"Error: Invalid M0 parameter\")\nelseif result.info == 3\n    println(\"Error: Invalid search interval\")\nelse\n    println(\"Error: Code $(result.info)\")\nend","category":"section"},{"location":"getting_started/#Quality-Assessment","page":"Getting Started","title":"Quality Assessment","text":"# Check convergence quality\nprintln(\"Final residual: $(result.epsout)\")\nprintln(\"Max individual residual: $(maximum(result.res[1:result.M]))\")\n\n# Verify eigenvalues are in target interval\nin_interval = [Emin <= λ <= Emax for λ in result.lambda[1:result.M]]\nprintln(\"All eigenvalues in interval: $(all(in_interval))\")\n\n# Check orthogonality of eigenvectors (if B = I)\nQ = result.q[:, 1:result.M]\northogonality_error = norm(Q'*Q - I)\nprintln(\"Orthogonality error: $orthogonality_error\")\n\n","category":"section"},{"location":"getting_started/#Common-Workflows","page":"Getting Started","title":"Common Workflows","text":"","category":"section"},{"location":"getting_started/#Workflow-1:-Finding-Specific-Eigenvalues","page":"Getting Started","title":"Workflow 1: Finding Specific Eigenvalues","text":"Problem: You need the 10 eigenvalues closest to 5.0\n\nusing FeastKit\n\n# Strategy: Search in a small interval around 5.0\ncenter = 5.0\nwidth = 0.1\nresult = feast(A, (center - width, center + width), M0=15)\n\nif result.M >= 10\n    closest_10 = result.lambda[1:10]\n    println(\"10 eigenvalues closest to 5.0: $closest_10\")\nelse\n    println(\"Found only $(result.M) eigenvalues, try wider interval\")\nend","category":"section"},{"location":"getting_started/#Workflow-2:-Eigenvalue-Counting","page":"Getting Started","title":"Workflow 2: Eigenvalue Counting","text":"Problem: How many eigenvalues are in [0, 1]?\n\n# Use FeastKit to count eigenvalues\nresult = feast(A, (0.0, 1.0), M0=100)  # Large M0 for counting\n\nprintln(\"Number of eigenvalues in [0,1]: $(result.M)\")\n\n# For more precise counting, use the rational function\nrational_values = feast_rational(test_points, 0.0, 1.0, fpm)\n# Values near 1.0 indicate eigenvalues nearby","category":"section"},{"location":"getting_started/#Workflow-3:-Parameter-Tuning","page":"Getting Started","title":"Workflow 3: Parameter Tuning","text":"Problem: FeastKit isn't converging well\n\n# Step 1: Check if eigenvalues exist in your interval\nbounds = feast_validate_interval(A, (Emin, Emax))\nprintln(\"Estimated eigenvalue range: $bounds\")\n\n# Step 2: Adjust FeastKit parameters\nfpm = zeros(Int, 64)\nfeastinit!(fpm)\nfpm[1] = 1      # Print level (0=silent, 1=summary, 2=detailed)\nfpm[2] = 16     # Integration points (8-32 typical)\nfmp[3] = 12     # Tolerance: 10^(-fmp[3])\nfpm[4] = 50     # Max refinement iterations\n\nresult = feast(A, (Emin, Emax), M0=20, fpm=fpm)\n\n# Step 3: Try different integration methods\nresult_zolotarev = feast(A, (Emin, Emax), M0=20, \n                        integration_method=:zolotarev, \n                        integration_points=12)","category":"section"},{"location":"getting_started/#Workflow-4:-Large-Scale-Problems","page":"Getting Started","title":"Workflow 4: Large-Scale Problems","text":"Problem: Matrix has millions of unknowns\n\n# Convert to matrix-free \nfunction matvec!(y, x)\n    # Your efficient A*x implementation\n    # Use BLAS, threading, GPU, etc.\nend\n\nA_op = LinearOperator{Float64}(matvec!, (n, n), issymmetric=true)\n\n# Use appropriate iterative solver\nresult = feast(A_op, (Emin, Emax), M0=10,\n              solver=:cg,  # or :gmres, :bicgstab\n              solver_opts=(rtol=1e-6, maxiter=1000))\n\n# Monitor memory usage\nprintln(\"Memory used: $(Base.summarysize(result) / 1e6) MB\")\n\n","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/#Ready-for-More?","page":"Getting Started","title":"Ready for More?","text":"Now that you understand the basics, explore these advanced topics:","category":"section"},{"location":"getting_started/#Performance-Optimization","page":"Getting Started","title":"Performance Optimization","text":"Matrix-Free Interface - Handle matrices too large for memory\nParallel Computing - Use multiple cores and nodes\nPerformance Tips - Speed and memory optimization","category":"section"},{"location":"getting_started/#Advanced-Features","page":"Getting Started","title":"Advanced Features","text":"Custom Contour Integration - Zolotarev, Gauss-Legendre methods\nComplex Eigenvalues - Non-Hermitian problems\nPolynomial Eigenvalue Problems - Quadratic and higher-order","category":"section"},{"location":"getting_started/#Real-Applications","page":"Getting Started","title":"Real Applications","text":"Structural Dynamics - Vibration analysis\nQuantum Mechanics - Electronic structure\nFluid Dynamics - Stability analysis\nNetwork Analysis - Graph eigenvalues","category":"section"},{"location":"getting_started/#Quick-Reference-Card","page":"Getting Started","title":"Quick Reference Card","text":"Keep this handy while coding:\n\n# Basic usage\nresult = feast(A, (Emin, Emax), M0=10)\n\n# Generalized problem  \nresult = feast(A, B, (Emin, Emax), M0=10)\n\n# Matrix-free\nA_op = LinearOperator{Float64}(matvec!, (n,n), issymmetric=true)\nresult = feast(A_op, (Emin, Emax), M0=10, solver=:cg)\n\n# Complex eigenvalues\nresult = feast_general(A, B, center, radius, M0=10)\n\n# Check results\nif result.info == 0\n    eigenvalues = result.lambda[1:result.M]\n    eigenvectors = result.q[:, 1:result.M]\nend","category":"section"},{"location":"getting_started/#Getting-Help","page":"Getting Started","title":"Getting Help","text":"Full API: API Reference\nIssues: GitHub Issues  \nCommunity: GitHub Discussions\nContact: your-email@domain.com\n\n\n\n<div align=\"center\">   <p><strong>Congratulations! You're now ready to use FeastKit.jl effectively.</strong></p>   Explore the API Reference · See more Examples </div>","category":"section"},{"location":"polynomial_problems/#Polynomial-Eigenvalue-Problems","page":"Polynomial Problems","title":"Polynomial Eigenvalue Problems","text":"Solve P(λ) x = 0 where P(λ) = A0 + λ A1 + λ² A2 + ...\n\nusing FeastKit\ncoeffs = [A0, A1, A2]  # Complex or real matrices\ncenter, radius = 0.0 + 0.0im, 1.0\nres = feast_polynomial(coeffs, center, radius, M0=20)\n\nTip: Scale/shift to keep eigenvalues inside a reasonably sized circle.","category":"section"},{"location":"examples/#Examples-and-Tutorials","page":"Examples","title":"Examples and Tutorials","text":"Comprehensive collection of FeastKit.jl examples from basic usage to advanced applications.","category":"section"},{"location":"examples/#Table-of-Contents","page":"Examples","title":"Table of Contents","text":"Basic Examples\nScientific Computing Applications  \nMatrix-Free Examples\nAdvanced Features\nPerformance Examples\nReal-World Applications\n\n","category":"section"},{"location":"examples/#Basic-Examples","page":"Examples","title":"Basic Examples","text":"","category":"section"},{"location":"examples/#Example-1:-Your-First-FeastKit-Calculation","page":"Examples","title":"Example 1: Your First FeastKit Calculation","text":"Problem: Find eigenvalues of a simple symmetric matrix.\n\nusing FeastKit, LinearAlgebra\n\n# Create a 5×5 symmetric matrix\nA = [4.0  -1.0   0.0   0.0   0.0\n    -1.0   4.0  -1.0   0.0   0.0  \n     0.0  -1.0   4.0  -1.0   0.0\n     0.0   0.0  -1.0   4.0  -1.0\n     0.0   0.0   0.0  -1.0   4.0]\n\nprintln(\"Matrix A:\")\ndisplay(A)\n\n# Find eigenvalues between 2 and 6\nresult = feast(A, (2.0, 6.0), M0=5)\n\nprintln(\"\\\\nFEAST Results:\")\nprintln(\"Status: $(result.info == 0 ? \"Success\" : \"Failed\")\")\nprintln(\"Found $(result.M) eigenvalues\")\n\nfor i in 1:result.M\n    λ = result.lambda[i]\n    println(\"λ[$i] = $λ\")\nend\n\n# Compare with Julia's built-in eigensolver\nall_eigvals = sort(eigvals(A))\nprintln(\"\\\\nAll eigenvalues (Julia): $all_eigvals\")\n\nExpected Output:\n\nFound 5 eigenvalues\nλ[1] = 2.0\nλ[2] = 3.0\nλ[3] = 4.0  \nλ[4] = 5.0\nλ[5] = 6.0","category":"section"},{"location":"examples/#Example-2:-Sparse-Matrix-Eigenvalues","page":"Examples","title":"Example 2: Sparse Matrix Eigenvalues","text":"Problem: Find eigenvalues of a large sparse tridiagonal matrix.\n\nusing FeastKit, SparseArrays, LinearAlgebra\n\n# Create large sparse tridiagonal matrix  \nn = 1000\nA = spdiagm(-1 => -ones(n-1), 0 => 2*ones(n), 1 => -ones(n-1))\n\nprintln(\"Sparse matrix: $(n)×$(n) with $(nnz(A)) nonzeros\")\n\n# Find the 10 smallest eigenvalues\n# For this tridiagonal matrix: λₖ = 2 - 2*cos(kπ/(n+1))\nλ_min = 2 - 2*cos(π/(n+1))      # ≈ 0.0001  \nλ_10 = 2 - 2*cos(10π/(n+1))     # ≈ 0.001\n\nprintln(\"Expected λ₁ ≈ $λ_min\")\nprintln(\"Expected λ₁₀ ≈ $λ_10\")\n\n# FeastKit search\nresult = feast(A, (λ_min * 0.9, λ_10 * 1.1), M0=12)\n\nprintln(\"\\\\nFEAST found $(result.M) eigenvalues:\")\nfor i in 1:result.M\n    k = round(Int, acos(1 - result.lambda[i]/2) * (n+1) / π)\n    λ_exact = 2 - 2*cos(k*π/(n+1))\n    error = abs(result.lambda[i] - λ_exact)\n    println(\"λ[$i] = $(result.lambda[i]) (exact: $λ_exact, error: $error)\")\nend","category":"section"},{"location":"examples/#Example-3:-Generalized-Eigenvalue-Problem","page":"Examples","title":"Example 3: Generalized Eigenvalue Problem","text":"Problem: Solve Ax = λB*x with two different matrices.\n\nusing FeastKit, LinearAlgebra\n\n# Create matrices A (stiffness) and B (mass)\nn = 100\nA = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))  # Stiffness\nB = SymTridiagonal(1.0 * ones(n), 0.1 * ones(n-1))   # Mass\n\nprintln(\"Generalized eigenvalue problem: A*x = λ*B*x\")\nprintln(\"A: $(n)×$(n) tridiagonal (stiffness)\")  \nprintln(\"B: $(n)×$(n) tridiagonal (mass)\")\n\n# Find eigenvalues between 0.5 and 2.5\nresult = feast(A, B, (0.5, 2.5), M0=15)\n\nprintln(\"\\\\nResults:\")\nprintln(\"Found $(result.M) generalized eigenvalues\")\n\n# Display first few eigenvalues and check generalized orthogonality  \nfor i in 1:min(5, result.M)\n    λ = result.lambda[i]\n    x = result.q[:, i]\n    \n    # Check: A*x = λ*B*x\n    residual = norm(A*x - λ*(B*x))\n    println(\"λ[$i] = $λ (residual: $residual)\")\nend\n\n# Check B-orthogonality of eigenvectors: X'*B*X = I\nif result.M > 1\n    X = result.q[:, 1:result.M]\n    orthogonality = norm(X' * B * X - I)\n    println(\"\\\\nB-orthogonality error: $orthogonality\")\nend\n\n","category":"section"},{"location":"examples/#Scientific-Computing-Applications","page":"Examples","title":"Scientific Computing Applications","text":"","category":"section"},{"location":"examples/#Example-4:-1D-Wave-Equation-(Vibrating-String)","page":"Examples","title":"Example 4: 1D Wave Equation (Vibrating String)","text":"Problem: Find natural frequencies of a vibrating string.\n\nusing FeastKit, LinearAlgebra, Plots\n\n# Physical parameters\nL = 1.0      # String length\nT = 100.0    # Tension\nρ = 1.0      # Linear density  \nn = 500      # Discretization points\n\n# Discretization\nh = L / (n + 1)\nx = h * (1:n)\n\n# Finite difference matrices\n# d²u/dx² ≈ (u[i-1] - 2u[i] + u[i+1])/h²\nA = (T/h^2) * SymTridiagonal(-2.0 * ones(n), ones(n-1))  # -T * d²/dx²\nB = ρ * I  # Mass matrix\n\nprintln(\"1D Wave Equation: -T*d²u/dx² = ω²*ρ*u\")\nprintln(\"String length: $L, Tension: $T, Density: $ρ\")\nprintln(\"Discretized with $n points, h = $h\")\n\n# Find first few natural frequencies\n# Analytical: ωₖ = kπ√(T/ρ)/L\nω_max = 5π * sqrt(T/ρ) / L  # First 5 modes\nω²_max = ω_max^2\n\nresult = feast(A, B, (0.1, ω²_max), M0=8)\n\nprintln(\"\\\\nNatural frequencies (Hz):\")\nfrequencies = sqrt.(result.lambda[1:result.M]) / (2π)\n\nfor i in 1:result.M\n    ω_analytical = i * π * sqrt(T/ρ) / L\n    f_analytical = ω_analytical / (2π)\n    error = abs(frequencies[i] - f_analytical)\n    \n    println(\"Mode $i: f = $(frequencies[i]) Hz (exact: $f_analytical Hz, error: $error)\")\nend\n\n# Plot mode shapes\nif result.M >= 3\n    p = plot(x, result.q[:, 1], label=\"Mode 1\", linewidth=2)\n    plot!(p, x, result.q[:, 2], label=\"Mode 2\", linewidth=2)\n    plot!(p, x, result.q[:, 3], label=\"Mode 3\", linewidth=2)\n    xlabel!(p, \"Position x\")\n    ylabel!(p, \"Amplitude\")  \n    title!(p, \"Vibrating String Mode Shapes\")\n    display(p)\nend","category":"section"},{"location":"examples/#Example-5:-2D-Membrane-Vibrations-(Drum-Head)","page":"Examples","title":"Example 5: 2D Membrane Vibrations (Drum Head)","text":"Problem: Find vibrational modes of a circular drum.\n\nusing FeastKit, LinearAlgebra\n\n# 2D Laplacian on square domain (approximating circular drum)\nnx, ny = 50, 50\nn = nx * ny\nh = 1.0 / (nx + 1)\n\nprintln(\"2D Membrane: -∇²u = ω²u on unit square\")\nprintln(\"Grid: $(nx)×$(ny), spacing: $h\")\n\n# Matrix-free 2D Laplacian with Dirichlet boundary conditions\nfunction laplacian_2d!(y, x)\n    fill!(y, 0)\n    \n    for j in 1:ny, i in 1:nx\n        k = (j-1) * nx + i\n        \n        # Central difference: -∇²u ≈ -(4u - u_left - u_right - u_up - u_down)/h²\n        y[k] += 4 * x[k] / h^2\n        \n        # Neighbors (with zero Dirichlet boundaries)  \n        if i > 1\n            y[k] -= x[k-1] / h^2\n        end\n        if i < nx\n            y[k] -= x[k+1] / h^2\n        end\n        if j > 1\n            y[k] -= x[k-nx] / h^2  \n        end\n        if j < ny\n            y[k] -= x[k+nx] / h^2\n        end\n    end\nend\n\n# Create matrix-free operator\nA_op = LinearOperator{Float64}(laplacian_2d!, (n, n), \n                              issymmetric=true, isposdef=true)\n\n# Find fundamental modes (lowest frequencies)\n# Analytical for square: ωₘₙ² = π²(m² + n²) for m,n = 1,2,3,...  \nω²_fundamental = π^2 * (1^2 + 1^2)  # Mode (1,1)\nω²_search_max = π^2 * (2^2 + 2^2)   # Up to mode (2,2)\n\nprintln(\"Searching for eigenvalues up to $(ω²_search_max)\")\nprintln(\"Fundamental frequency ω₁₁² = $ω²_fundamental\")\n\nresult = feast(A_op, (0.8 * ω²_fundamental, 1.2 * ω²_search_max), \n              M0=10, solver=:cg, solver_opts=(rtol=1e-6, maxiter=500))\n\nprintln(\"\\\\n2D Membrane Modes:\")\nprintln(\"Found $(result.M) eigenfrequencies\")\n\n# Match with analytical modes\nanalytical_modes = [(1,1), (1,2), (2,1), (2,2)]\nfor i in 1:min(result.M, length(analytical_modes))\n    m, n = analytical_modes[i]\n    ω²_exact = π^2 * (m^2 + n^2)  \n    ω²_feast = result.lambda[i]\n    error = abs(ω²_feast - ω²_exact)\n    \n    println(\"Mode ($m,$n): ω² = $ω²_feast (exact: $ω²_exact, error: $error)\")\nend\n\n# Visualize first mode shape\nif result.M > 0\n    mode1 = reshape(result.q[:, 1], nx, ny)\n    println(\"\\\\nFirst mode shape computed (reshape to $(nx)×$(ny) grid for visualization)\")\nend","category":"section"},{"location":"examples/#Example-6:-Quantum-Harmonic-Oscillator","page":"Examples","title":"Example 6: Quantum Harmonic Oscillator","text":"Problem: Find energy levels of quantum harmonic oscillator.\n\nusing FeastKit, LinearAlgebra\n\n# 1D Quantum Harmonic Oscillator: H = -½d²/dx² + ½x²\n# Discretized on [-L, L] with N points\n\nL = 6.0     # Domain size (covers most of wavefunction)\nN = 1000    # Grid points\nh = 2L / (N - 1)\nx = range(-L, L, length=N)\n\nprintln(\"Quantum Harmonic Oscillator: H = -½d²/dx² + ½x²\")\nprintln(\"Domain: x ∈ [$(-L), $L], grid spacing: $h\")\n\n# Hamiltonian matrix (using finite differences)\n# Kinetic energy: -½d²/dx² ≈ -½(ψ[i+1] - 2ψ[i] + ψ[i-1])/h²\n# Potential energy: ½x²ψ[i]\n\nH = zeros(N, N)\n\nfor i in 1:N\n    # Potential energy\n    H[i, i] += 0.5 * x[i]^2\n    \n    # Kinetic energy (finite difference)\n    if i > 1\n        H[i, i-1] += -0.5 / h^2\n    end\n    if i < N  \n        H[i, i+1] += -0.5 / h^2\n    end\n    H[i, i] += 0.5 / h^2  # Central term from kinetic\nend\n\n# Enforce boundary conditions (ψ = 0 at boundaries)\nH[1, :] .= 0; H[1, 1] = 1e10\nH[N, :] .= 0; H[N, N] = 1e10\n\nprintln(\"Hamiltonian matrix: $(N)×$(N)\")\n\n# Find ground state and first few excited states  \n# Analytical energies: Eₙ = n + ½ for n = 0, 1, 2, ...\nE_ground = 0.5      # Ground state\nE_max = 5.5         # Up to n = 5\n\nresult = feast(H, (E_ground - 0.1, E_max + 0.1), M0=8)\n\nprintln(\"\\\\nQuantum Energy Levels:\")\nprintln(\"Found $(result.M) energy eigenstates\")\n\nfor i in 1:result.M\n    E_exact = (i-1) + 0.5  # n = 0, 1, 2, ...\n    E_computed = result.lambda[i]\n    error = abs(E_computed - E_exact)\n    \n    println(\"n=$(i-1): E = $E_computed (exact: $E_exact, error: $error)\")\nend\n\n# Check normalization of wavefunctions\nprintln(\"\\\\nWavefunction normalization check:\")\nfor i in 1:min(3, result.M)\n    ψ = result.q[:, i]\n    norm_ψ = sqrt(sum(ψ.^2) * h)  # Numerical integration\n    println(\"||ψ_$(i-1)||₂ = $norm_ψ (should be ≈ 1)\")\nend\n\n","category":"section"},{"location":"examples/#Matrix-Free-Examples","page":"Examples","title":"Matrix-Free Examples","text":"","category":"section"},{"location":"examples/#Example-7:-Large-Scale-Finite-Element-Problem","page":"Examples","title":"Example 7: Large-Scale Finite Element Problem","text":"Problem: Structural eigenanalysis without storing global matrices.\n\nusing FeastKit, SparseArrays\n\n# Simulate large finite element problem  \n# In reality, this would come from FE assembly\nn_nodes = 100000  # Very large problem\nn_dofs = 3 * n_nodes  # 3 DOFs per node (x, y, z)\n\nprintln(\"Large-scale structural analysis\")  \nprintln(\"Nodes: $(n_nodes), DOFs: $(n_dofs)\")\nprintln(\"Memory for full matrix: $(8 * n_dofs^2 / 1e9) GB\")\nprintln(\"Memory for matrix-free: $(8 * n_dofs / 1e6) MB\")\n\n# Matrix-free stiffness matrix operation K*u\nfunction stiffness_matvec!(Ku, u)\n    # In practice: loop over elements, compute element stiffness,\n    # and assemble contributions to Ku\n    \n    # Simplified: 3D Laplacian-like operator  \n    fill!(Ku, 0)\n    \n    # Simple 3D finite difference stencil (6-point)\n    n = length(u) ÷ 3  # Number of nodes\n    \n    for node in 1:n\n        for dof in 1:3  # x, y, z components\n            idx = 3*(node-1) + dof\n            \n            # Diagonal term (self-stiffness)\n            Ku[idx] += 6.0 * u[idx]\n            \n            # Coupling with neighboring nodes (simplified connectivity)\n            for neighbor_offset in [-1, 1, -10, 10, -100, 100]  # 3D grid-like\n                neighbor = node + neighbor_offset\n                if 1 <= neighbor <= n\n                    neighbor_idx = 3*(neighbor-1) + dof\n                    Ku[idx] -= u[neighbor_idx]\n                end\n            end\n        end\n    end\nend\n\n# Matrix-free mass matrix operation M*u\nfunction mass_matvec!(Mu, u)\n    # Diagonal mass matrix (lumped mass)\n    @. Mu = 1.0 * u\nend\n\n# Create matrix-free operators\nK_op = LinearOperator{Float64}(stiffness_matvec!, (n_dofs, n_dofs), issymmetric=true)\nM_op = LinearOperator{Float64}(mass_matvec!, (n_dofs, n_dofs), \n                              issymmetric=true, isposdef=true)\n\nprintln(\"\\\\nCreated matrix-free operators\")\nprintln(\"Searching for natural frequencies between 0.1 and 2.0 Hz...\")\n\n# Find structural modes (natural frequencies)\nω²_min, ω²_max = (2π * 0.1)^2, (2π * 2.0)^2\n\nresult = feast(K_op, M_op, (ω²_min, ω²_max), M0=20,\n              solver=:cg,\n              solver_opts=(rtol=1e-4, maxiter=200))\n\nprintln(\"\\\\nStructural Analysis Results:\")\nprintln(\"Found $(result.M) vibrational modes\")\n\nfrequencies_Hz = sqrt.(result.lambda[1:result.M]) / (2π)\nfor i in 1:result.M\n    println(\"Mode $i: f = $(frequencies_Hz[i]) Hz\")\nend\n\nprintln(\"\\\\nMatrix-free calculation completed successfully!\")\nprintln(\"Peak memory usage: ~$(8 * n_dofs * result.M / 1e6) MB\")","category":"section"},{"location":"examples/#Example-8:-Iterative-Solver-Comparison","page":"Examples","title":"Example 8: Iterative Solver Comparison","text":"Problem: Compare different iterative solvers for matrix-free FeastKit.\n\nusing FeastKit, LinearAlgebra, BenchmarkTools\n\n# Test problem: 2D Poisson equation\nnx, ny = 200, 200  \nn = nx * ny\nh = 1.0 / (nx + 1)\n\nprintln(\"2D Poisson Eigenvalue Problem\")\nprintln(\"Grid: $(nx)×$(ny), DOFs: $(n)\")\n\n# Matrix-free Laplacian\nfunction laplacian!(y, x)\n    fill!(y, 0)\n    for j in 1:ny, i in 1:nx\n        k = (j-1) * nx + i\n        y[k] += 4 * x[k] / h^2\n        \n        i > 1  && (y[k] -= x[k-1] / h^2)\n        i < nx && (y[k] -= x[k+1] / h^2)  \n        j > 1  && (y[k] -= x[k-nx] / h^2)\n        j < ny && (y[k] -= x[k+nx] / h^2)\n    end\nend\n\nA_op = LinearOperator{Float64}(laplacian!, (n, n), issymmetric=true, isposdef=true)\ninterval = (10.0, 50.0)  # Search range\n\n# Test different iterative solvers\nsolvers = [\n    (:cg, \"Conjugate Gradient\"),\n    (:gmres, \"GMRES\"), \n    (:bicgstab, \"BiCGSTAB(l)\")\n]\n\nresults = Dict()\n\nfor (solver_name, description) in solvers\n    println(\"\\\\n\" * \"=\"^50)\n    println(\"Testing solver: $description\")\n    \n    # Configure solver options\n    if solver_name == :cg\n        opts = (rtol=1e-6, maxiter=300)\n    elseif solver_name == :gmres  \n        opts = (rtol=1e-6, restart=50, maxiter=300)\n    else  # bicgstab\n        opts = (rtol=1e-6, l=2, maxiter=300)\n    end\n    \n    # Time the calculation\n    time_taken = @elapsed begin\n        result = feast(A_op, interval, M0=8, \n                      solver=solver_name, solver_opts=opts)\n    end\n    \n    results[solver_name] = (result=result, time=time_taken)\n    \n    println(\"Solver: $description\")\n    println(\"  Time: $(time_taken) seconds\")\n    println(\"  Eigenvalues found: $(result.M)\")\n    println(\"  FeastKit status: $(result.info == 0 ? \"Success\" : \"Failed\")\")\n    println(\"  Convergence: $(result.epsout)\")\n    \n    if result.M > 0\n        println(\"  First 3 eigenvalues: $(result.lambda[1:min(3, result.M)])\")\n    end\nend\n\n# Summary comparison\nprintln(\"\\\\n\" * \"=\"^60)\nprintln(\"SOLVER COMPARISON SUMMARY\")\nprintln(\"=\"^60)\nprintf_str = \"%-20s %-10s %-8s %-12s\\\\n\"\n@printf(printf_str, \"Solver\", \"Time (s)\", \"Found\", \"Status\")\nprintln(\"-\"^60)\n\nfor (solver_name, description) in solvers\n    if haskey(results, solver_name)\n        r = results[solver_name]\n        status = r.result.info == 0 ? \"Success\" : \"Failed\"\n        @printf(printf_str, description, r.time, r.result.M, status)\n    end\nend\n\n","category":"section"},{"location":"examples/#Advanced-Features","page":"Examples","title":"Advanced Features","text":"","category":"section"},{"location":"examples/#Example-9:-Custom-Contour-Integration","page":"Examples","title":"Example 9: Custom Contour Integration","text":"Problem: Use advanced integration methods for challenging problems.\n\nusing FeastKit, LinearAlgebra\n\n# Create a challenging matrix (clustered eigenvalues)\nn = 200\nA = diagm(0 => vcat(0.98:0.002:1.02, 2.0:0.1:5.0))  # Tight cluster + spread\nA = A + 0.01 * randn(n, n)  # Add small random perturbation  \nA = (A + A') / 2  # Ensure symmetry\n\nprintln(\"Matrix with clustered eigenvalues\")\nprintln(\"Cluster around 1.0: [0.98, 1.02]\")\nprintln(\"Spread eigenvalues: [2.0, 5.0]\")\n\ntarget_interval = (0.97, 1.03)  # Focus on the cluster\n\n# Compare different integration methods\nintegration_methods = [\n    (0, \"Gauss-Legendre\"),\n    (1, \"Trapezoidal\"), \n    (2, \"Zolotarev\")\n]\n\nprintln(\"\\\\nComparing integration methods for clustered eigenvalues:\")\n\nfor (method_id, method_name) in integration_methods\n    println(\"\\\\n\" * \"-\"^40)\n    println(\"Method: $method_name\")\n    \n    # Test different numbers of integration points\n    for ne in [8, 16, 24]\n        # Generate custom contour\n        contour = feast_contour_expert(target_interval[1], target_interval[2], \n                                     ne, method_id, 100)\n        \n        println(\"\\\\n  Integration points: $ne\")\n        println(\"  Contour nodes: $(length(contour.Zne))\")\n        \n        # Create custom FMP parameters\n        fpm = zeros(Int, 64)\n        feastinit!(fpm)\n        fpm[2] = ne           # Number of points\n        fpm[16] = method_id   # Integration method\n        fpm[18] = 100         # Circular contour\n        \n        result = feast(A, target_interval, M0=20, fpm=fpm)\n        \n        # Find how many eigenvalues are actually in the target interval\n        exact_in_interval = count(λ -> target_interval[1] <= λ <= target_interval[2], \n                                eigvals(A))\n        \n        println(\"    Found: $(result.M) eigenvalues\")\n        println(\"    Expected: $exact_in_interval eigenvalues\")  \n        println(\"    Convergence: $(result.epsout)\")\n        println(\"    Iterations: $(result.loop)\")\n    end\nend","category":"section"},{"location":"examples/#Example-10:-Complex-Eigenvalue-Problems","page":"Examples","title":"Example 10: Complex Eigenvalue Problems","text":"Problem: Find eigenvalues of non-Hermitian matrices in complex regions.\n\nusing FeastKit, LinearAlgebra, Random\n\nRandom.seed!(123)\n\n# Create non-Hermitian matrix with known eigenvalue distribution\nn = 100\n\n# Upper Hessenberg matrix (like from Arnoldi process)\nA = triu(randn(ComplexF64, n, n), -1)  # Upper Hessenberg\nA[diagind(A)] .+= 2.0 + 0.5im          # Shift diagonal \n\nprintln(\"Non-Hermitian matrix ($(n)×$(n) upper Hessenberg)\")\nprintln(\"Expected eigenvalues near 2.0 + 0.5i\")\n\n# Identity mass matrix\nB = Matrix{ComplexF64}(I, n, n)\n\n# Define circular search regions\nsearch_regions = [\n    (2.0 + 0.5im, 1.0, \"Main cluster\"),\n    (0.0 + 0.0im, 2.0, \"Origin region\"), \n    (3.0 + 2.0im, 1.5, \"Upper right\")\n]\n\nprintln(\"\\\\nSearching in multiple circular regions:\")\n\nall_found_eigenvalues = ComplexF64[]\n\nfor (center, radius, description) in search_regions\n    println(\"\\\\n\" * \"=\"^50) \n    println(\"Region: $description\")\n    println(\"Center: $center, Radius: $radius\")\n    \n    result = feast_general(A, B, center, radius, M0=15)\n    \n    println(\"Status: $(result.info == 0 ? \"Success\" : \"Failed\")\")  \n    println(\"Found: $(result.M) eigenvalues\")\n    \n    if result.M > 0\n        println(\"Eigenvalues in this region:\")\n        region_eigenvalues = result.lambda[1:result.M]\n        \n        for (i, λ) in enumerate(region_eigenvalues)\n            distance = abs(λ - center)\n            inside = distance <= radius\n            println(\"  λ[$i] = $(round(λ, digits=4)) \" *\n                   \"(distance: $(round(distance, digits=3)), \" *\n                   \"inside: $inside)\")\n        end\n        \n        # Add to global list (avoid duplicates)  \n        for λ in region_eigenvalues\n            if !any(abs.(λ .- all_found_eigenvalues) .< 1e-8)\n                push!(all_found_eigenvalues, λ)\n            end\n        end\n    end\nend\n\nprintln(\"\\\\n\" * \"=\"^60)\nprintln(\"SUMMARY: Found $(length(all_found_eigenvalues)) unique eigenvalues\")\n\n# Compare with full eigendecomposition\ntrue_eigenvalues = eigvals(A)\nprintln(\"Total eigenvalues in matrix: $(length(true_eigenvalues))\")\n\n# Visualize eigenvalue distribution (if plotting available)\ntry\n    using Plots\n    \n    p = scatter(real.(true_eigenvalues), imag.(true_eigenvalues), \n               label=\"All eigenvalues\", alpha=0.6, ms=4)\n    scatter!(p, real.(all_found_eigenvalues), imag.(all_found_eigenvalues),\n            label=\"FeastKit found\", color=:red, ms=6, alpha=0.8)\n    \n    # Draw search circles\n    θ = 0:0.1:2π\n    for (center, radius, description) in search_regions\n        circle_x = real(center) .+ radius .* cos.(θ)  \n        circle_y = imag(center) .+ radius .* sin.(θ)\n        plot!(p, circle_x, circle_y, label=\"$description region\", \n              linestyle=:dash, linewidth=2)\n    end\n    \n    xlabel!(p, \"Real part\")\n    ylabel!(p, \"Imaginary part\")\n    title!(p, \"Complex Eigenvalue Distribution\")\n    display(p)\n    \ncatch e\n    println(\"Plotting not available: $e\")\nend","category":"section"},{"location":"examples/#Example-11:-Polynomial-Eigenvalue-Problems","page":"Examples","title":"Example 11: Polynomial Eigenvalue Problems","text":"Problem: Solve quadratic eigenvalue problem (λ²M + λC + K)x = 0.\n\nusing FeastKit, LinearAlgebra\n\n# Quadratic eigenvalue problem: (λ²M + λC + K)x = 0\n# Example: Damped vibration problem\n\nn = 50  # System size\n\n# Create coefficient matrices\nK = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))  # Stiffness\nC = 0.1 * SymTridiagonal(ones(n), zeros(n-1))         # Damping  \nM = Matrix{Float64}(I, n, n)                          # Mass\n\nprintln(\"Quadratic Eigenvalue Problem: (λ²M + λC + K)x = 0\")\nprintln(\"Damped vibration system\")\nprintln(\"System size: $(n)×$(n)\")\n\n# Convert to matrix-free operators for polynomial FeastKit\nK_op = LinearOperator{ComplexF64}((y, x) -> mul!(y, K, real.(x)), (n, n))\nC_op = LinearOperator{ComplexF64}((y, x) -> mul!(y, C, real.(x)), (n, n))  \nM_op = LinearOperator{ComplexF64}((y, x) -> mul!(y, M, real.(x)), (n, n))\n\n# Coefficient array: P(λ) = K + λC + λ²M\ncoeffs = [K_op, C_op, M_op]\n\nprintln(\"Polynomial coefficients: P(λ) = K + λC + λ²M\")\n\n# Search for eigenvalues near origin (low-frequency modes)\ncenter = 0.0 + 0.0im\nradius = 2.0\n\nprintln(\"Searching in circular region: center = $center, radius = $radius\")\n\nresult = feast_polynomial(coeffs, center, radius, M0=10)\n\nprintln(\"\\\\nPolynomial Eigenvalue Results:\")\nprintln(\"Status: $(result.info == 0 ? \"Success\" : \"Failed\")\")\nprintln(\"Found: $(result.M) eigenvalues\")\n\nif result.M > 0\n    println(\"\\\\nEigenvalues (should be complex conjugate pairs):\")\n    for i in 1:result.M\n        λ = result.lambda[i]\n        freq = abs(λ) / (2π)\n        damping_ratio = -real(λ) / abs(λ)\n        \n        println(\"λ[$i] = $(round(λ, digits=6))\")  \n        println(\"  Frequency: $(round(freq, digits=4)) Hz\")\n        println(\"  Damping ratio: $(round(damping_ratio, digits=4))\")\n        println()\n    end\n    \n    # Verify polynomial eigenvalue equation: P(λ)x = 0\n    println(\"Verification (residual norms):\")\n    for i in 1:min(3, result.M)\n        λ = result.lambda[i]\n        x = result.q[:, i]\n        \n        # Compute P(λ)x = (λ²M + λC + K)x  \n        residual = λ^2 * (M * real.(x)) + λ * (C * real.(x)) + K * real.(x)\n        residual_norm = norm(residual)\n        \n        println(\"||P(λ[$i])x[$i]|| = $residual_norm\")\n    end\nend\n\n# Compare with linearized version (for validation)\nprintln(\"\\\\n\" * \"-\"^50)\nprintln(\"Comparison with linearized eigenvalue problem:\")\n\n# Linearization: [ 0   I ] [x]     [x]\n#                [-K  -C] [λx] = λ[-M  0][λx] \n#\n# This gives 2n eigenvalues (including spurious ones)\n\nA_lin = [zeros(n, n)  Matrix{Float64}(I, n, n);\n         -K           -C                       ]\nB_lin = [-M           zeros(n, n);\n         zeros(n, n)  Matrix{Float64}(I, n, n)]\n\n# Convert to complex for general eigenvalue solver\nA_lin_c = ComplexF64.(A_lin)\nB_lin_c = ComplexF64.(B_lin)\n\nresult_lin = feast_general(A_lin_c, B_lin_c, center, radius, M0=20)\n\nprintln(\"Linearized problem found: $(result_lin.M) eigenvalues\")\nif result_lin.M > 0\n    println(\"First few linearized eigenvalues:\")\n    for i in 1:min(5, result_lin.M)\n        println(\"  λ_lin[$i] = $(round(result_lin.lambda[i], digits=6))\")\n    end\nend\n\n","category":"section"},{"location":"examples/#Performance-Examples","page":"Examples","title":"Performance Examples","text":"","category":"section"},{"location":"examples/#Example-12:-Memory-Usage-Comparison","page":"Examples","title":"Example 12: Memory Usage Comparison","text":"Problem: Compare memory usage of different approaches.\n\nusing FeastKit, LinearAlgebra, SparseArrays\n\n# Test different problem sizes and approaches\nproblem_sizes = [1000, 5000, 10000, 20000]\n\nprintln(\"Memory Usage Comparison: Dense vs Sparse vs Matrix-Free\")\nprintln(\"=\"^70)\n@printf(\"%-10s %-15s %-15s %-15s\\\\n\", \"Size\", \"Dense (MB)\", \"Sparse (MB)\", \"Matrix-Free (MB)\")\nprintln(\"-\"^70)\n\nfor n in problem_sizes\n    # Dense matrix memory\n    dense_memory = 8 * n^2 / 1e6  # 8 bytes per Float64\n    \n    # Sparse matrix memory (assuming 0.1% density)\n    nnz_sparse = round(Int, 0.001 * n^2)\n    sparse_memory = (8 * nnz_sparse + 4 * (nnz_sparse + n + 1)) / 1e6  # data + indices\n    \n    # Matrix-free memory (just vectors for FeastKit)\n    M0 = 10\n    matfree_memory = 8 * n * M0 / 1e6  # Workspace vectors\n    \n    @printf(\"%-10d %-15.1f %-15.1f %-15.1f\\\\n\", \n           n, dense_memory, sparse_memory, matfree_memory)\n    \n    # Demonstrate actual usage for largest manageable size\n    if n <= 5000\n        println(\"\\\\nTesting n = $n:\")\n        \n        # Create test matrix  \n        A_dense = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\n        A_sparse = sparse(A_dense)\n        \n        function A_matvec!(y, x)\n            y[1] = 2*x[1] - x[2]\n            for i in 2:n-1\n                y[i] = -x[i-1] + 2*x[i] - x[i+1]  \n            end\n            y[n] = -x[n-1] + 2*x[n]\n        end\n        A_op = LinearOperator{Float64}(A_matvec!, (n, n), issymmetric=true)\n        \n        # Time each approach  \n        interval = (0.01, 0.1)\n        M0 = 5\n        \n        println(\"  Dense matrix:\")\n        @time result_dense = feast(A_dense, interval, M0=M0)\n        println(\"    Found: $(result_dense.M) eigenvalues\")\n        \n        println(\"  Sparse matrix:\")  \n        @time result_sparse = feast(A_sparse, interval, M0=M0)\n        println(\"    Found: $(result_sparse.M) eigenvalues\")\n        \n        println(\"  Matrix-free:\")\n        @time result_matfree = feast(A_op, interval, M0=M0, solver=:cg)  \n        println(\"    Found: $(result_matfree.M) eigenvalues\")\n        \n        # Verify all give same results\n        if result_dense.M == result_sparse.M == result_matfree.M\n            max_diff = maximum(abs.(result_dense.lambda[1:result_dense.M] .- \n                                  result_sparse.lambda[1:result_sparse.M]))\n            println(\"  Max difference (dense vs sparse): $max_diff\")\n            \n            max_diff_mf = maximum(abs.(result_dense.lambda[1:result_dense.M] .- \n                                     result_matfree.lambda[1:result_matfree.M]))\n            println(\"  Max difference (dense vs matrix-free): $max_diff_mf\")\n        end\n        \n        println()\n    end\nend","category":"section"},{"location":"examples/#Example-13:-Parallel-Performance","page":"Examples","title":"Example 13: Parallel Performance","text":"Problem: Demonstrate parallel FeastKit capabilities.\n\nusing FeastKit, LinearAlgebra, Distributed\n\n# Add worker processes\nif nprocs() == 1\n    addprocs(4)  # Add 4 worker processes\nend\n\n@everywhere using FeastKit, LinearAlgebra\n\nprintln(\"Parallel FeastKit Performance Test\")\nprintln(\"Available processes: $(nprocs())\")\nprintln(\"Worker processes: $(nworkers())\")\n\n# Create test problem\nn = 5000\nA = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\ninterval = (0.01, 0.5)\nM0 = 20\n\nprintln(\"\\\\nProblem: $(n)×$(n) tridiagonal matrix\")\nprintln(\"Search interval: $interval\")\nprintln(\"Max eigenvalues: $M0\")\n\n# Compare serial vs parallel performance\nprintln(\"\\\\n\" * \"=\"^50)\nprintln(\"Performance Comparison:\")\n\n# Serial FeastKit\nprintln(\"\\\\nSerial FeastKit:\")\nGC.gc()  # Clean garbage before timing\nserial_time = @elapsed begin\n    result_serial = feast(A, interval, M0=M0, parallel=false)\nend\n\nprintln(\"  Time: $(serial_time) seconds\")\nprintln(\"  Eigenvalues found: $(result_serial.M)\")\nprintln(\"  Status: $(result_serial.info == 0 ? \"Success\" : \"Failed\")\")\n\n# Parallel FeastKit with threading  \nif Threads.nthreads() > 1\n    println(\"\\\\nThreaded FeastKit ($(Threads.nthreads()) threads):\")\n    GC.gc()\n    threaded_time = @elapsed begin\n        result_threaded = feast(A, interval, M0=M0, parallel=:threads)\n    end\n    \n    println(\"  Time: $(threaded_time) seconds\")\n    println(\"  Speedup: $(serial_time / threaded_time)x\") \n    println(\"  Eigenvalues found: $(result_threaded.M)\")\n    println(\"  Status: $(result_threaded.info == 0 ? \"Success\" : \"Failed\")\")\nend\n\n# Distributed parallel FeastKit\nif nworkers() > 1\n    println(\"\\\\nDistributed FeastKit ($(nworkers()) workers):\")\n    GC.gc()\n    distributed_time = @elapsed begin\n        result_distributed = feast(A, interval, M0=M0, parallel=:distributed)\n    end\n    \n    println(\"  Time: $(distributed_time) seconds\") \n    println(\"  Speedup: $(serial_time / distributed_time)x\")\n    println(\"  Eigenvalues found: $(result_distributed.M)\")\n    println(\"  Status: $(result_distributed.info == 0 ? \"Success\" : \"Failed\")\")\n    \n    # Verify results match\n    if result_serial.M == result_distributed.M > 0\n        max_diff = maximum(abs.(result_serial.lambda[1:result_serial.M] .- \n                              result_distributed.lambda[1:result_distributed.M]))\n        println(\"  Max difference from serial: $max_diff\")\n    end\nend\n\n# Performance summary\nprintln(\"\\\\n\" * \"=\"^50)\nprintln(\"Performance Summary:\")\nprintln(\"Serial time: $(serial_time) seconds\") \n\nif @isdefined(threaded_time)\n    println(\"Threading speedup: $(serial_time / threaded_time)x\")\nend\n\nif @isdefined(distributed_time)  \n    println(\"Distributed speedup: $(serial_time / distributed_time)x\")\nend\n\nprintln(\"\\\\nNote: Speedup depends on problem size, hardware, and communication overhead.\")\nprintln(\"Larger problems generally show better parallel scalability.\")\n\n","category":"section"},{"location":"examples/#Real-World-Applications","page":"Examples","title":"Real-World Applications","text":"","category":"section"},{"location":"examples/#Example-14:-Electronic-Structure-(Tight-Binding-Model)","page":"Examples","title":"Example 14: Electronic Structure (Tight-Binding Model)","text":"Problem: Find electronic band structure using tight-binding approximation.\n\nusing FeastKit, LinearAlgebra\n\n# 1D Tight-binding model for electrons in a periodic chain\n# H = -t∑(c†ᵢcᵢ₊₁ + c†ᵢ₊₁cᵢ) + ε∑c†ᵢcᵢ\n\nN = 1000    # Number of sites  \nt = 1.0     # Hopping parameter\nε = 0.0     # On-site energy\n\nprintln(\"1D Tight-Binding Electronic Structure\")\nprintln(\"Chain length: $N sites\")  \nprintln(\"Hopping parameter: $t\")\nprintln(\"On-site energy: $ε\")\n\n# Hamiltonian matrix (tridiagonal)\nH = SymTridiagonal(ε * ones(N), -t * ones(N-1))\n\n# For periodic boundary conditions, add corner elements\nH_periodic = Matrix(H)\nH_periodic[1, N] = H_periodic[N, 1] = -t\n\nprintln(\"Boundary conditions: periodic\")\nprintln(\"Expected energy band: [$(ε-2t), $(ε+2t)]\")\n\n# Find states in different parts of the band\n\n# Valence band (filled states, lower energies)\nE_valence_min, E_valence_max = ε - 2*t + 0.1, ε - 0.5  \nresult_valence = feast(H_periodic, (E_valence_min, E_valence_max), M0=50)\n\nprintln(\"\\\\nValence band [$E_valence_min, $E_valence_max]:\")\nprintln(\"  Found $(result_valence.M) states\")\n\n# Conduction band (empty states, higher energies)\nE_conduct_min, E_conduct_max = ε + 0.5, ε + 2*t - 0.1\nresult_conduct = feast(H_periodic, (E_conduct_min, E_conduct_max), M0=50)\n\nprintln(\"\\\\nConduction band [$E_conduct_min, $E_conduct_max]:\")\nprintln(\"  Found $(result_conduct.M) states\")\n\n# States near Fermi level (band gap region)\nE_gap_min, E_gap_max = ε - 0.5, ε + 0.5  \nresult_gap = feast(H_periodic, (E_gap_min, E_gap_max), M0=20)\n\nprintln(\"\\\\nBand gap region [$E_gap_min, $E_gap_max]:\")\nprintln(\"  Found $(result_gap.M) states\")\n\n# Calculate density of states\nall_energies = vcat(\n    result_valence.M > 0 ? result_valence.lambda[1:result_valence.M] : Float64[],\n    result_gap.M > 0 ? result_gap.lambda[1:result_gap.M] : Float64[],  \n    result_conduct.M > 0 ? result_conduct.lambda[1:result_conduct.M] : Float64[]\n)\n\nsort!(all_energies)\n\nprintln(\"\\\\nElectronic Structure Summary:\")\nprintln(\"Total states found: $(length(all_energies))\")\nif length(all_energies) > 10\n    println(\"Lowest 5 energies: $(all_energies[1:5])\")\n    println(\"Highest 5 energies: $(all_energies[end-4:end])\")\nend\n\n# Analyze band gap\nif result_gap.M == 0\n    valence_top = result_valence.M > 0 ? maximum(result_valence.lambda[1:result_valence.M]) : -Inf\n    conduct_bottom = result_conduct.M > 0 ? minimum(result_conduct.lambda[1:result_conduct.M]) : Inf\n    \n    if isfinite(valence_top) && isfinite(conduct_bottom)\n        band_gap = conduct_bottom - valence_top\n        println(\"\\\\nBand gap: $(band_gap) eV\")\n        println(\"Valence band maximum: $valence_top\")  \n        println(\"Conduction band minimum: $conduct_bottom\")\n    end\nelse\n    println(\"\\\\nStates found in gap region - may be surface states or numerical artifacts\")\nend","category":"section"},{"location":"examples/#Example-15:-Fluid-Dynamics-Stability-Analysis","page":"Examples","title":"Example 15: Fluid Dynamics Stability Analysis","text":"Problem: Linear stability analysis of fluid flow.\n\nusing FeastKit, LinearAlgebra\n\n# Linear stability analysis of 2D channel flow\n# Solve generalized eigenvalue problem: (A - λB)φ = 0\n# where A is the linearized Navier-Stokes operator\n\n# Flow parameters  \nRe = 1000.0    # Reynolds number\nnx, ny = 64, 32  # Grid resolution\nLx, Ly = 4π, 2.0 # Domain size  \n\nn = nx * ny      # Total degrees of freedom\n\nprintln(\"2D Channel Flow Stability Analysis\")\nprintln(\"Reynolds number: $Re\")\nprintln(\"Domain: $Lx × $Ly\")  \nprintln(\"Grid: $(nx) × $(ny)\")\nprintln(\"DOFs: $n\")\n\n# Create simplified stability operators (matrix-free)\n# In practice, these would come from discretized Navier-Stokes\n\nfunction stability_operator!(y, x)\n    # Simplified 2D advection-diffusion operator\n    # Represents linearized Navier-Stokes around base flow\n    \n    fill!(y, 0)\n    \n    # Grid spacing\n    hx, hy = Lx/nx, Ly/ny\n    \n    for j in 1:ny, i in 1:nx\n        k = (j-1)*nx + i\n        \n        # Base flow velocity (parabolic profile)  \n        y_coord = (j-1) * hy\n        U_base = 4 * (y_coord/Ly) * (1 - y_coord/Ly)  # Parabolic\n        \n        # Advection terms: U·∇φ\n        if i > 1 && i < nx\n            y[k] += U_base * (x[k+1] - x[k-1]) / (2*hx)  # ∂φ/∂x\n        end\n        \n        # Viscous terms: (1/Re)∇²φ  \n        y[k] -= 4 * x[k] / (Re * hx^2)  # Central difference\n        if i > 1\n            y[k] += x[k-1] / (Re * hx^2)\n        end\n        if i < nx\n            y[k] += x[k+1] / (Re * hx^2)\n        end\n        if j > 1\n            y[k] += x[k-nx] / (Re * hy^2)\n        end  \n        if j < ny\n            y[k] += x[k+nx] / (Re * hy^2)\n        end\n        \n        # Pressure gradient and continuity (simplified)\n        y[k] += 0.1 * x[k]  # Regularization\n    end\nend\n\nfunction mass_operator!(y, x)\n    # Time derivative term  \n    copy!(y, x)\nend\n\n# Create matrix-free operators\nA_op = LinearOperator{ComplexF64}(\n    (y, x) -> stability_operator!(y, complex(real.(x))), (n, n)\n)\nB_op = LinearOperator{ComplexF64}(\n    (y, x) -> mass_operator!(y, complex(real.(x))), (n, n)\n)\n\n# Search for unstable modes (positive real part)\n# and neutral/stable modes near imaginary axis\n\nsearch_regions = [\n    (0.1 + 0.0im, 0.5, \"Unstable modes\"),           # Right half-plane\n    (0.0 + 2.0im, 1.0, \"High frequency modes\"),     # Imaginary axis, high freq  \n    (0.0 + 0.5im, 0.8, \"Low frequency modes\")       # Imaginary axis, low freq\n]\n\nprintln(\"\\\\nSearching for instability modes:\")\nall_eigenvalues = ComplexF64[]\n\nfor (center, radius, description) in search_regions\n    println(\"\\\\n\" * \"=\"^40)\n    println(\"Region: $description\")\n    println(\"Center: $center, Radius: $radius\")\n    \n    result = feast_general(A_op, B_op, center, radius, M0=10)\n    \n    println(\"Status: $(result.info == 0 ? \"Success\" : \"Failed\")\")\n    println(\"Found: $(result.M) modes\")\n    \n    if result.M > 0\n        println(\"Eigenvalues (growth rate + i*frequency):\")\n        region_modes = result.lambda[1:result.M]\n        \n        for (i, λ) in enumerate(region_modes)\n            growth_rate = real(λ)\n            frequency = imag(λ)\n            stability = growth_rate > 1e-6 ? \"UNSTABLE\" : \n                       growth_rate < -1e-6 ? \"stable\" : \"neutral\"\n                       \n            println(\"  λ[$i] = $(round(λ, digits=6)) ($stability)\")\n            println(\"    Growth rate: $(round(growth_rate, digits=6))\")  \n            println(\"    Frequency: $(round(frequency, digits=6))\")\n        end\n        \n        append!(all_eigenvalues, region_modes)\n    end\nend\n\n# Stability analysis summary\nprintln(\"\\\\n\" * \"=\"^60)\nprintln(\"FLOW STABILITY SUMMARY\")  \nprintln(\"=\"^60)\n\nif length(all_eigenvalues) > 0\n    unstable_modes = filter(λ -> real(λ) > 1e-6, all_eigenvalues)\n    neutral_modes = filter(λ -> abs(real(λ)) <= 1e-6, all_eigenvalues)  \n    stable_modes = filter(λ -> real(λ) < -1e-6, all_eigenvalues)\n    \n    println(\"Total modes found: $(length(all_eigenvalues))\")\n    println(\"Unstable modes: $(length(unstable_modes))\")\n    println(\"Neutral modes: $(length(neutral_modes))\")\n    println(\"Stable modes: $(length(stable_modes))\")\n    \n    if length(unstable_modes) > 0\n        max_growth = maximum(real.(unstable_modes))\n        println(\"\\\\nFLOW IS UNSTABLE!\")\n        println(\"Maximum growth rate: $max_growth\")\n        \n        # Find most unstable mode\n        most_unstable_idx = argmax(real.(unstable_modes))\n        λ_most_unstable = unstable_modes[most_unstable_idx]\n        println(\"Most unstable mode: $λ_most_unstable\")\n        println(\"Doubling time: $(log(2)/real(λ_most_unstable))\")\n        \n    else\n        println(\"\\\\nFLOW APPEARS STABLE\")\n        println(\"All found modes have negative or zero growth rates\")\n    end\nelse\n    println(\"No eigenvalues found in searched regions\")\n    println(\"Flow stability could not be determined\")\nend\n\n\n\n<div align=\"center\">   <p><strong>Complete Examples Collection for FeastKit.jl</strong></p>   <p>From basic usage to advanced scientific applications</p>   ← Getting Started | API Reference → </div>","category":"section"},{"location":"#FeastKit.jl","page":"Home","title":"FeastKit.jl","text":"Fast Eigenvalue Algorithm using Spectral Transformations in Julia\n\nQuick Start | Examples | API Reference | Advanced Features\n\n","category":"section"},{"location":"#What-is-FEAST?","page":"Home","title":"What is FEAST?","text":"FeastKit.jl is a Julia implementation of the FEAST eigenvalue algorithm, a powerful numerical method for finding eigenvalues and eigenvectors of large sparse matrices within specified intervals or regions. Unlike traditional methods that compute all eigenvalues, FeastKit allows you to:\n\nTarget specific eigenvalues in intervals [Emin, Emax] or complex regions\nHandle very large problems (millions of unknowns) efficiently\nWork matrix-free without storing explicit matrices\nLeverage parallelization for high-performance computing\nUse custom contour integration for optimal convergence","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Feature Description\nInterval Targeting Find eigenvalues only in [Emin, Emax]\nMatrix-Free Use callback functions instead of explicit matrices\nParallel Computing MPI and shared-memory parallelization\nMultiple Matrix Types Dense, sparse, banded, custom operators\nComplex Eigenvalues General non-Hermitian problems\nCustom Integration Gauss-Legendre, Zolotarev, custom contours\n\n","category":"section"},{"location":"#quick-start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"FeastKit\")  # When available from registry\n\n# Or for development:\nPkg.add(url=\"https://github.com/subhk/FeastKit.jl\")","category":"section"},{"location":"#Your-First-FeastKit-Calculation","page":"Home","title":"Your First FeastKit Calculation","text":"using FeastKit, LinearAlgebra\n\n# Create a test matrix (1000x1000 tridiagonal)\nn = 1000\nA = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\n\n# Find eigenvalues between 0.5 and 1.5\nresult = feast(A, (0.5, 1.5), M0=10)\n\nprintln(\"Found $(result.M) eigenvalues:\")\nprintln(result.lambda[1:result.M])\n\nThat's it! FeastKit found the eigenvalues in your target interval.","category":"section"},{"location":"#Matrix-Free-Example","page":"Home","title":"Matrix-Free Example","text":"For very large problems, use matrix-free operations:\n\n# Define matrix-vector multiplication (no explicit matrix needed!)\nfunction A_mul!(y, x)\n    n = length(x)\n    y[1] = 2*x[1] - x[2]\n    for i in 2:n-1\n        y[i] = -x[i-1] + 2*x[i] - x[i+1]\n    end\n    y[n] = -x[n-1] + 2*x[n]\nend\n\n# Create matrix-free operator\nA_op = LinearOperator{Float64}(A_mul!, (n, n), issymmetric=true)\n\n# Solve the same way!\nresult = feast(A_op, (0.5, 1.5), M0=10)\n\n","category":"section"},{"location":"#examples-gallery","page":"Home","title":"Examples Gallery","text":"","category":"section"},{"location":"#Dense-Matrix-Eigenvalues","page":"Home","title":"Dense Matrix Eigenvalues","text":"using FeastKit, LinearAlgebra\n\n# Create a random symmetric matrix\nn = 500\nA = randn(n, n)\nA = A + A'  # Make symmetric\n\n# Find eigenvalues near zero\nresult = feast(A, (-1.0, 1.0), M0=20)\n\nprintln(\"Eigenvalues near zero:\")\nfor i in 1:result.M\n    println(\"λ[$i] = $(result.lambda[i])\")\nend","category":"section"},{"location":"#Sparse-Matrix-Problems","page":"Home","title":"Sparse Matrix Problems","text":"using FeastKit, SparseArrays\n\n# Large sparse symmetric matrix\nn = 10000\nA = sprand(n, n, 0.001)  # 0.1% density\nA = A + A' + 5*I         # Make symmetric positive definite\n\n# Find largest eigenvalues\nresult = feast(A, (4.8, 5.2), M0=8)\n\nprintln(\"Largest eigenvalues: $(result.lambda[1:result.M])\")","category":"section"},{"location":"#Generalized-Eigenvalue-Problem","page":"Home","title":"Generalized Eigenvalue Problem","text":"using FeastKit\n\n# Create matrices A and B\nn = 1000\nA = SymTridiagonal(2.0 * ones(n), -1.0 * ones(n-1))\nB = SymTridiagonal(3.0 * ones(n), -0.5 * ones(n-1))\n\n# Solve A*x = λ*B*x\nresult = feast(A, B, (0.1, 0.8), M0=15)\n\nprintln(\"Generalized eigenvalues: $(result.lambda[1:result.M])\")","category":"section"},{"location":"#Complex-Non-Hermitian-Problems","page":"Home","title":"Complex Non-Hermitian Problems","text":"using FeastKit\n\n# Non-symmetric matrix with complex eigenvalues\nn = 200\nA = randn(ComplexF64, n, n)\nB = Matrix{ComplexF64}(I, n, n)\n\n# Search in circular region\ncenter = 0.0 + 0.0im\nradius = 2.0\n\nresult = feast_general(A, B, center, radius, M0=15)\n\nprintln(\"Complex eigenvalues:\")\nfor i in 1:result.M\n    λ = result.lambda[i]\n    println(\"λ[$i] = $(real(λ)) + $(imag(λ))im\")\nend\n\n","category":"section"},{"location":"#core-concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#The-FEAST-Algorithm","page":"Home","title":"The FEAST Algorithm","text":"The FEAST algorithm uses contour integration in the complex plane to extract eigenvalues in specified regions. The key idea:\n\nDefine a contour around your region of interest\nIntegrate along the contour using spectral projectors\nExtract eigenvalues inside the contour via reduced eigenvalue problems\n\n     Im(z)\n       ↑\n   ┌───●───●───┐  ← Integration contour\n   │   ●   ●   │    (eigenvalues inside)\n───●───●───●───●──→ Re(z)\n   │   ●   ●   │\n   └───●───●───┘","category":"section"},{"location":"#Search-Regions","page":"Home","title":"Search Regions","text":"Real Intervals: For symmetric/Hermitian matrices\n\nresult = feast(A, (Emin, Emax), M0=10)\n\nComplex Regions: For general matrices\n\nresult = feast_general(A, B, center, radius, M0=10)\n\nCustom Contours: For advanced users\n\ncontour = feast_contour_expert(Emin, Emax, 16, 2, 100)  # Zolotarev integration\n\n","category":"section"},{"location":"#Performance-Guide","page":"Home","title":"Performance Guide","text":"","category":"section"},{"location":"#Choosing-Parameters","page":"Home","title":"Choosing Parameters","text":"Parameter Description Typical Values Impact\nM0 Max eigenvalues to find 10-50 Memory usage, accuracy\nne Integration points 8-32 Accuracy vs speed\ntol Convergence tolerance 1e-12 Accuracy vs iterations\nmaxiter Max refinement loops 20-100 Convergence robustness","category":"section"},{"location":"#Memory-Usage","page":"Home","title":"Memory Usage","text":"Problem Size Standard FeastKit Matrix-Free FeastKit\n1,000 × 1,000 ~24 MB ~1 MB\n10,000 × 10,000 ~2.4 GB ~10 MB\n100,000 × 100,000 ~240 GB ~100 MB","category":"section"},{"location":"#Performance-Tips","page":"Home","title":"Performance Tips","text":"Use matrix-free for large problems\nChoose appropriate solvers: CG for SPD, GMRES for general\nTune integration points: More points = better accuracy, slower\nEnable parallelization for very large problems\nUse custom contours for challenging geometries\n\n","category":"section"},{"location":"#Troubleshooting","page":"Home","title":"Troubleshooting","text":"","category":"section"},{"location":"#No-eigenvalues-found","page":"Home","title":"No eigenvalues found","text":"Cause: Search interval doesn't contain eigenvalues\n\nSolutions:\n\n# Check eigenvalue bounds first\nbounds = feast_validate_interval(A, (Emin, Emax))\nprintln(\"Estimated eigenvalue range: $bounds\")\n\n# Use a broader interval\nresult = feast(A, (bounds[1], bounds[2]), M0=10)","category":"section"},{"location":"#Linear-solver-not-converging","page":"Home","title":"Linear solver not converging","text":"Cause: Iterative solver issues in matrix-free mode\n\nSolutions:\n\n# Increase solver tolerance and iterations\nresult = feast(A_op, interval,\n              solver=:gmres,\n              solver_opts=(rtol=1e-4, maxiter=2000, restart=50))\n\n# Try different solver\nresult = feast(A_op, interval, solver=:bicgstab)","category":"section"},{"location":"#Memory-allocation-failed","page":"Home","title":"Memory allocation failed","text":"Cause: Problem too large for available memory\n\nSolutions:\n\n# Switch to matrix-free interface\nA_op = LinearOperator{Float64}(A_mul!, size(A))\nresult = feast(A_op, interval, M0=10)\n\n# Reduce M0 (max eigenvalues)\nresult = feast(A, interval, M0=5)  # Instead of M0=20","category":"section"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"Documentation: Check API Reference\nIssues: Report bugs on GitHub Issues\nDiscussions: Ask questions on GitHub Discussions\n\n","category":"section"},{"location":"#What's-Next?","page":"Home","title":"What's Next?","text":"Ready to dive deeper? Explore these advanced topics:\n\nMatrix-Free Interface - For large-scale problems\nParallel Computing - MPI and threading\nCustom Contours - Advanced integration methods\nPerformance Optimization - Speed and memory tips\nExamples - Real-world applications","category":"section"},{"location":"#Quick-Navigation","page":"Home","title":"Quick Navigation","text":"I want to... Go to...\nGet started immediately Quick Start\nSee working examples Examples Gallery\nFind function documentation API Reference\nSolve very large problems Matrix-Free Guide\nUse multiple processors Parallel Computing\nOptimize performance Performance Guide\n\n\n\nReady to solve your eigenvalue problems with FeastKit.jl? Start Computing →\n\n\n\nFeastKit.jl | GitHub | Releases | License","category":"section"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"Key references for the FEAST algorithm and spectral projection methods:\n\nE. Polizzi, \"Density-Matrix-Based Algorithm for Solving Eigenvalue Problems,\" Phys. Rev. B 79, 115112 (2009).\nFEAST documentation and publications: https://www.feast-solver.org/","category":"section"},{"location":"developer_guide/#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"This section outlines the project layout and development tips.\n\nSource: src/\nTests: test/\nDocs: docs/\n\nBuild and test locally:\n\njulia --project -e 'using Pkg; Pkg.resolve(); Pkg.instantiate(); Pkg.test()'\n\nDocs (MkDocs): see docs/README.md for commands to serve and deploy.","category":"section"}]
}
